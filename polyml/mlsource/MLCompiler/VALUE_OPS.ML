(*
    Copyright (c) 2000
        Cambridge University Technical Services Limited

    Modified David C.J. Matthews 2008-9.

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.
    
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.
    
    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*)

(*
    Title:      Operations on global and local values.
    Author:     Dave Matthews, Cambridge University Computer Laboratory
    Copyright   Cambridge University 1986
*)

functor VALUE_OPS (

structure LEX : LEXSIG;
structure CODETREE : CODETREESIG
structure STRUCTVALS : STRUCTVALSIG;
structure TYPESTRUCT : TYPETREESIG

structure PRINTTABLE :
sig
  type typeConstrs
  type codetree
  
  val addOverload: string * typeConstrs * codetree -> unit
  val getOverloads: string -> (typeConstrs * codetree) list
  val getOverload: string * typeConstrs * (unit->codetree) -> codetree
end;

structure UNIVERSALTABLE:
sig
  type universal = Universal.universal
  type univTable
  type 'a iter

  val univOver: univTable -> (string * universal) iter;
end;

structure DEBUG :
sig
    val printDepthFunTag : (unit->int) Universal.tag
    val errorDepthTag: int Universal.tag
    val getParameter :
       'a Universal.tag -> Universal.universal list -> 'a
end;

structure MISC :
sig
  exception InternalError of string; (* compiler error *)
  
  val quickSort : ('a -> 'a -> bool) -> 'a list -> 'a list
  
  type 'a iter;
  val for    : 'a iter -> ('a -> 'b) -> unit
  val iterList : 'a iter -> 'a list
end;

structure PRETTY : PRETTYSIG;

structure ADDRESS :
sig
  type machineWord;      (* any legal bit-pattern (tag = 0 or 1) *)
  type address;   (* an object that's represented as a pointer *) 
  type short = Word.word;   (* an object that's represented as a 30-bit int *)

  val wordEq : 'a * 'a -> bool

  val unsafeCast : 'a -> 'b;
  
  val isShort   : 'a -> bool;

  (* The following casts are always safe *)
  val toMachineWord : 'a    -> machineWord;
  
  (* The following casts are checked at run-time *)
  val toShort   : 'a -> short;
  val toAddress : 'a -> address;
  
  val alloc:  (short * Word8.word * machineWord)  -> address;

  val loadByte:   (address * short) -> Word8.word;
  val loadWord:   (address * short) -> machineWord;
  val assignWord: (address * short * machineWord)  -> unit
  val lock:       address -> unit

  val length: address -> short;
   
  val F_words     : Word8.word;
  val F_bytes     : Word8.word;
  val F_mutable   : Word8.word;
end;

structure UTILITIES :
sig
  val splitString: string -> { first:string,second:string }
end;

structure COPIER: COPIERSIG

structure TYPEIDCODE: TYPEIDCODESIG

sharing STRUCTVALS.Sharing = TYPESTRUCT.Sharing = LEX.Sharing = PRETTY.Sharing
      = COPIER.Sharing = CODETREE.Sharing = PRINTTABLE = ADDRESS = UNIVERSALTABLE = MISC
      = TYPEIDCODE.Sharing

) : VALUEOPSSIG =

(*****************************************************************************)
(*                  VALUEOPS functor body                                    *)
(*****************************************************************************)
struct
  open MISC; 
  open PRETTY;
  
  open LEX;
  open CODETREE;
  open TYPESTRUCT; (* Open this first because unitType is in STRUCTVALS as well. *)
  open Universal; (* for tag etc. *)
  open STRUCTVALS;
  open PRINTTABLE;
  open DEBUG;
  open ADDRESS;
  open UNIVERSALTABLE;
  open RuntimeCalls; (* for POLY_SYS and EXC numbers *)
  open UTILITIES;
  open TYPEIDCODE
  open COPIER
  
  val length   = List.length;
  
  (* gets a value from the run-time system; 
    usually this is a closure, but sometimes it's an int.  *)
  val ioOp : int -> machineWord = RunCall.run_call1 POLY_SYS_io_operation;

  val orb = Word8.orb
  infix 7 orb;
     (* Functions to construct the values. *)

    fun mkGconstr (name, typeof, code, nullary, constrs, location) =
       makeValueConstr (name, typeof, nullary, constrs, Global code, location);

    (* Global variable *)
    val mkGvar = makeGlobalV

    (* Local variable - Generated by the second pass. *)
    fun mkVar (name, typeof, locations) =  makeLocalV (name, typeof, ref 0, ref 0, locations);

    (* Value in a local structure or a functor argument.  May be simple value, exception
        or constructor. *)
    fun mkSelectedVar (Value { access = Formal addr, name, typeOf, class, locations, ...}, base, openLocs) =
        (* If the argument is "formal" set the base to the base structure. *)
        Value{name=name, typeOf=typeOf, class=class,
            access=Selected{addr=addr, base=base}, locations=openLocs @ locations, references = NONE}

    |   mkSelectedVar (Value { access = Global code, name, typeOf, class, locations, ...}, _, openLocs) =
        (* Global: We need to add the location information. *)
        Value{name=name, typeOf=typeOf, class=class, access=Global code,
              locations=openLocs @ locations, references = NONE}

    |   mkSelectedVar(selected, _, _) = selected (* Overloaded? *);

    (* Construct a global exception. *)
    fun mkGex (name, typeof, code, locations) =
        Value{ name = name, typeOf = typeof, access = Global code,
           class = Exception, locations = locations, references = NONE }
 
    (* Construct a local exception. *)
    fun mkEx (name, typeof, locations) = 
        Value{ name = name, typeOf = typeof,
           access = Local{addr = ref 0, level = ref 0},
           class = Exception, locations=locations, references = NONE }

 (* Copy a datatype (if necessary), converting the constructors to selections on
    a base structure.  This is used both when opening a structure and also for
    replicating a datatype. *)
 fun mkSelectedType(tcons: typeConstrs, newName: string, baseStruct: structVals option, locations): typeConstrs =
    let
        (* Create a new constructor with the same unique ID. *)
        val typeID = tcIdentifier tcons;
        val newTypeCons =
            makeDatatypeConstr(newName, tcTypeVars tcons, typeID,
                            tcLetDepth tcons, locations);
        
        (* Copy the value constructors. *)
        fun copyAConstructor(Value{name=cName, typeOf, class, access, ...}) =
            let
                (* Copy the types of value constructors replacing
                   occurrences of the old type with the new one.
                   This is not strictly necessary but improves printing.
                   e.g. local datatype X = A | B in datatype Y = datatype X end;
                   A; prints  A: Y rather than A: X *)
                fun copyTypeCons (tcon : typeConstrs) : typeConstrs =
                    if sameTypeId(tcIdentifier tcon, typeID)
                    then newTypeCons
                    else tcon;
                fun copyTyp (t : types) : types =
                   copyType (t, fn x => x, (* Don't bother with type variables. *)
                       copyTypeCons);
                val newType = copyTyp typeOf;
                val newAccess =
                    case (access, baseStruct) of
                        (* If we are opening a structure we must have a base structure
                           and we turn Formal entries into Selected.  If we are replicating
                           a datatype within a signature the original constructors will
                           be Formal. *)
                        (Formal addr, SOME base) => Selected{base=base, addr=addr}
                    |    (Formal _, NONE) => access
                    |    _ => access; (* Probably already a global. *)
            in
                Value{name=cName, typeOf=newType, class=class, access=newAccess, locations=locations,
                      references = NONE}
            end
    
        val newValConstrs = map copyAConstructor (tcConstructors tcons)
    in
        tcSetConstructors(newTypeCons, newValConstrs);
        newTypeCons
    end

(*****************************************************************************)
(*             Representation of Datatype Constructors                       *)
(*****************************************************************************)
  (* These are the possible representations of a value constructor. *)
  datatype representations = 
    RefForm            (* As for OnlyOne but must be a monotype. *)
  | UnitForm           (* If the only value in an enumeration. *)
  | OnlyOne            (* If only one constructor, there is no tag or box. *)
                       (* Could be replaced by "UnboxedForm"? *)
    
  | EnumForm of int    (* Enumeration - argument is the number. (short?) *)
  | BoxedForm          (* Boxed but not tagged (only unary constructor) *)
  | UnboxedForm        (* Unboxed and untagged (only unary constructor) *)

  | ConstForm of machineWord         (* Constant - argument is a tagged value. *)
  | TaggedBox of int          (* Union - tagged and boxed.  i.e. the representation is a
                                 pair whose first word is the tag and second is the value. *)
  | TaggedTuple of int * int  (* Union - tagged but with in-line tuple. i.e. for a
                                   tuple of size n the representation is a tuple of size n+1
                                 whose first word contains the tag. *)


(* This makes the isConsTest "fn x => not (isShort x)" rather than
   "fn x => x <> 0", but that shouldn't give any worse code.
   If it does, we'll have to reinstate ConsForm as a primitive. *)
  val NilForm  = EnumForm 0;
  val ConsForm = UnboxedForm;
  
(* Similarly, this makes the tests for UnitForm and OnlyOne more
   expensive, but we shouldn't be generating them anyway (especially
   as the tests seem buggy). That's what fancy compilation
   of pattern-matching does for you! Of course, if it doesn't work,
   we can always reinstate them. SPF 22/10/94 *)
   
(* Don't do this ...
  val UnitForm = EnumForm 0;
... because it breaks the (hacky!) pretty-printing of arrays.
    (Array values are represented by a UnitForm value constructor;
    if we use an EnumForm instead, constrMatches fails, so we
    get a (handled) exception inside the pretty-printer. This
    is all very sad. The right fix would be to generalise
    use-defined pretty-printers to handle parameterised types, and
    add one of these for arrays.
    SPF 2/7/96 *)
(* I've done that although whether it fixes this particular problem
   or not I don't know. DCJM Sept 2000. *)

  val arg1     = mkLoad (~1, 0); (* saves a lot of garbage *)

    val mutableFlags = F_words orb F_mutable;

    (* allocate 1 mutable word, initialise to "v"; do not evaluate "early" *)
    fun refApplyCode (v: codetree) =
      mkEval
        (mkConst (ioOp POLY_SYS_alloc_store),
        [mkConst (toMachineWord 1), mkConst (toMachineWord mutableFlags), v],
        false);

(* Don't do this ...
    val OnlyOne  = UnboxedForm;
... because that gives the wrong test if the value isn't boxed. SPF 22/10/94 *)

  local
    
    fun abstract (doIt: codetree -> codetree) (name : string) : codetree =
      mkInlproc (doIt arg1, 0, 1, name);
  
    (* we use toShort to check that the tag actually fits in a 30-bit integer *)
    fun mkTag (tag:int) : codetree = mkConst (toMachineWord (toShort tag));

    (* tag now moved into first word SPF 22/10/94 *)
    (* get the tag from a TaggedBox or ConstForm *)
    fun loadTag (u: machineWord) : machineWord = 
      loadWord (toAddress u, 0w0); (* tag is first field *)

    fun identityApplyCode v = v;  (* no-op *)
    fun boxApplyCode v    = mkTuple [v];

    (* Inject into a union. Generate as mkTuple(arg, tag). *)
    (* we use toShort to check that the tag actually fits in a 30-bit integer *)
    fun tagBoxApplyCode (tag:int) (v : codetree) =
      mkTuple [mkTag tag, v];
              
    (* Inject into a tagged tuple - we could improve this if we knew that
       arg is an explicit tuple already, but the optimiser should do this
       anyway. I have also coded this using inline procedures with explicit
       applications because I can't work out how to make a well-formed
       block (because declartion addresses are *not* local to a block?)
       SPF 25/10/94 *)
    fun tagTupleCode (tag:int) (n:int) (name:string) : codetree =
    let
      (* copy n data fields out of ordinary record *)
      fun getFields i =
    if i < n then mkInd (i, arg1) :: getFields (i + 1) else [];
    in  
      mkInlproc (mkTuple (mkTag tag :: getFields 0), 0, 1, name)
    end;

    fun tagTupleApplyCode (tag:int) (n:int) (arg:codetree) : codetree =
      mkEval (tagTupleCode tag n "", [arg], true);

    fun taggedTupleDestructCode (n:int) (arg:codetree) : codetree =
    let
      (* copy n data fields out of tagged record *)
      fun getFields i =
    if i <= n then mkInd (i, arg1) :: getFields (i + 1) else [];
    
      val proc = mkInlproc (mkTuple (getFields 1), 0, 1, "")
    in  
      mkEval (proc, [arg], true)
    end;

    (* If we need to make a "real" functions, here's how *)
    val refCode      = abstract refApplyCode "ref";
(*  val consCode     = abstract identityApplyCode "::" *);
    val identityCode = abstract identityApplyCode;
    val boxCode      = abstract boxApplyCode;
    
    fun tagBoxCode (tag:int) = 
      abstract (tagBoxApplyCode tag);
      
    fun tagTupleCode (tag:int) (n:int) =
       abstract (tagTupleApplyCode tag n);

    fun testTag (tag: int) (v: codetree) =
      mkTestinteq (mkTag tag, v);
      
    fun testBoxedTag (tag: int) (v: codetree) : codetree =
      mkTestinteq (mkTag tag, mkInd (0, v)); (* tag is first field *)
       
    fun taggedBoxDestructCode (box : codetree) : codetree = 
      mkInd (1, box); (* contents is second field of record *)

    (* Use loadWord not indirect because the optimiser reorders indirections. *)
    fun refDestructCode (v : codetree) : codetree =
       mkEval 
         (mkConst (ioOp POLY_SYS_load_word),
         [v, CodeZero],
         false) (* NOT early *)
       
    fun testBoxed (v: codetree) : codetree = (* not (isShort v) *)
      mkEval
        (mkConst (ioOp POLY_SYS_not_bool),
        [mkEval (mkConst (ioOp POLY_SYS_is_short), [v], true)],
        true);
        
    fun boxedDestructCode (box : codetree) : codetree =
      mkInd (0, box);

  (* The run-time representation of the constructor's value *)
  fun constrMake (test: representations) (name: string) : codetree =
    case test of
      UnboxedForm          => identityCode name
    | BoxedForm            => boxCode name
    | TaggedBox tag        => tagBoxCode tag name
    | TaggedTuple (tag, n) => tagTupleCode tag n name
    | RefForm              => refCode
    | ConstForm c          => mkConst c (* tagged value. *)
    | EnumForm tag         => mkConst (toMachineWord (toShort tag))
    | OnlyOne              => identityCode name
    | UnitForm             => CodeZero
    ;

  (* How to apply the constructor at run-time *)
  fun constrApply (test: representations) : codetree -> codetree =
    case test of
      UnboxedForm          => identityApplyCode
    | BoxedForm            => boxApplyCode
    | RefForm              => refApplyCode
    | TaggedBox tag        => tagBoxApplyCode tag
    | TaggedTuple (tag, n) => tagTupleApplyCode tag n
    | OnlyOne              => identityApplyCode
    | _                    => 
        (fn _ => raise InternalError "constant can't be applied")

  (* The run-time test whether a value matches a constructor. *)
  fun constrMatch (test: representations) (value:codetree) : codetree =
    case test of
      UnboxedForm          => testBoxed value
    | BoxedForm            => testBoxed value
    | RefForm              => CodeTrue
    | EnumForm tag         => testTag tag value 
    | TaggedBox tag        => testBoxedTag tag value
    | TaggedTuple (tag, _) => testBoxedTag tag value
    | ConstForm c          => testBoxedTag (Word.toIntX (* May be signed. *) (toShort (loadTag c))) value
    | OnlyOne              => CodeTrue
    | UnitForm             => CodeTrue
    ;

  (* The compile-time test whether a value matches a constructor. *)
(*  fun constrMatches (test: representations) (value: word) : bool =
    case test of
      UnboxedForm          => not (isShort value)
    | BoxedForm            => not (isShort value)
    | RefForm              => true
    | EnumForm tag         => wordEq (value, toMachineWord tag)
    | TaggedBox tag        => wordEq (loadTag value, toMachineWord tag)
    | TaggedTuple (tag, n) => wordEq (loadTag value, toMachineWord tag)
    | ConstForm c          => wordEq (loadTag value, loadTag c)
    | OnlyOne              => true
    | UnitForm             => true
    ;
*)

  (* The run-time code to destruct a construction. *)
  (* shouldn't the CodeZero's raise an exception instead? *)
  fun constrDestruct (test: representations) (value: codetree) : codetree =
    case test of
      UnboxedForm          => identityApplyCode value
    | BoxedForm            => boxedDestructCode value
    | RefForm              => refDestructCode value
    | TaggedBox _        => taggedBoxDestructCode value
    | TaggedTuple (_, n) => taggedTupleDestructCode n value
    | OnlyOne              => identityApplyCode value
    | EnumForm _         => CodeZero (* To keep optimiser happy. *)
    | ConstForm _          => CodeZero (* (rather than raising an exception) *)
    | UnitForm             => CodeZero
    ;

  (* The compile-time function to destruct a construction. *)
(*  fun constrFetch (test: representations) (value: machineWord) : machineWord =
    case test of
      UnboxedForm         => value
    | BoxedForm           => loadBoxedValue value
    | RefForm             => loadBoxedValue value
    | TaggedBox tag       => loadTaggedBoxedValue value
    | TaggedTuple (tag,n) => loadTaggedTupleValue n value
    | OnlyOne             => value
    | EnumForm tag        => loadTag value (* shouldn't occur, but ... *)
    | ConstForm c         => value         (* shouldn't occur, but ... *)
    | UnitForm            => value         (* occurs for arrays! *)
    ;
*)

  in
     (* Constructors are now represented as run-time values.  A nullary constructor is
        a pair consisting of a test function and the constructor value.  A unary
        constructor is a triple: a test function, an injection function and a
        projection function.
        Previously constructors were handled entirely at compile with the appropriate
        functions inserted whenever a constructor was used.  This worked fine except
        in one case: when a datatype was used in a structure we couldn't use the optimal
        representation because it might match a datatype in a signature and we needed
        the same representation in both cases.  This arises if we have a datatype
        such as
            type t = int * int datatype s = X | Y of t
        We can use an optimised representation because we know that Y constructors are
        always boxed.  If we have
            type t = int datatype s = X | Y of t
        we can't do that and have to create tagged pairs for Y values.  Unfortunately
        we could pass either of these to a functor expecting a signature of the form
            sig type t datatype s = X | Y of t end
        If we handle constructors entirely at compile time we are forced to use the
        same representation for Y constructors in both cases. By passing the
        constructors as run-time values we can use different representations.
        This actually costs very little at run-time because functor are inlined
        so the constructor functions become inserted inline.  DCJM 18/5/01. *)

      fun createNullaryConstructor (test: representations, name: string): codetree =
      let
          val code =
              mkTuple[mkInlproc(constrMatch test arg1, 0, 1, name), (* Test function. *)
                    constrMake test name (* Value. *)]
      in
        (* Code generate the tuple now.  This saves us having multiple occurrences of
           the code but more importantly allows us to be able to print values of
           this datatype (printstruct uses evalue and that only works if we have
           a constant). *)
          genCode (code, [] (* No debugging output *)) ()
      end
    
      fun createUnaryConstructor(test: representations, name: string): codetree =
      let
          val code =
          mkTuple[mkInlproc(constrMatch test arg1, 0, 1, name), (* Test function. *)
                mkInlproc(constrApply test arg1, 0, 1, name), (* Injection function. *)
                mkInlproc(constrDestruct test arg1, 0, 1, name) (* Projection function. *)]
      in
        (* Code generate the tuple now. *)
          genCode (code, [] (* No debugging output *)) ()
      end

  end;

(* 
     RefForm is used for "ref" (only). We use various representations
     of datatype / abstype constructors.
   
     Nullary constructors are represented as:
        UnitForm     (if it's the only constructor in the datatype)
        EnumForm     (if there's no more than one unary constructor)
         ConstForm    (otherwise)
    
     Unary constructors are represented as:
        OnlyOne      (if it's the only constructor in the datatype)
        UnboxedForm  (if it's the only unary constructor, applied to a tuple)
        TaggedTuple  (if it's not the only unary constructor, applied to a tuple, and we don't need backwards compatibility)
        BoxedForm    (if it's the only unary constructor)
        TaggedBox    (otherwise)
        
     Note that we can't use UnboxedForm/TaggedTuple if the datatype
     might appear in a signature, because the signature might be ambiguous
     about whether the argument is a tuple or not. In these cases, we always
     use BoxedForm/TaggedBox instead.
      
     Note that we use ConstForm, not EnumForm, for nullary constructors
     when the unary constructors are represented as TaggedTuple/TaggedBox
     because that allows the TaggedBox test to be:
       
         fn w => wordEq (loadWord (w,0), tag)
     
     rather than:
     
         fn w => not (isShort w) andalso wordEq (loadWord (w,0), tag)
     
     In my ignorance, I tried combining EnumForms with TaggedBoxes
     *without* changing the TaggedBox test and got a lot of
     core dumps as my reward (the machine didn't like fetching the
     tag from address 5!).
     
     SPF 20/10/94
  *)
  
  
  datatype constructorKind =
    Nullary             (* a nullary constructor *)
  | UnaryGeneric        (* a normal unary constructor *)
  | UnaryFunction       (* unary constructor applied to a function *)
  | UnaryTupled of int  (* a unary constructor applied to a tuple of size n  *)
  ;

  (* Make an object with the appropriate tag. Doing it here means we
     only do it once for this object. *)
  fun genConstForm (n :int) : representations =
  let
    (* In the new datatype format, I've moved the tag word, so
       we only need a one-word object. SPF 26/5/95 *)
    val vec : address = alloc (0w1, F_words, toMachineWord n);
    val () = lock vec;
  in
    ConstForm (toMachineWord vec)
  end;
    
  (* Choose tags in the sequence 0, ~1, 1, ~2, 2, ... because that
     maximises the chance of the tag being implemented by "immediate"
     data in the low-level generator. Note this means that "bool"
     gets a *different* representation than what its natural datatype
     declaration would give! Of course, we can't do this for the
     "Old" representations anyway. SPF 18/2/1998
  *)
  fun nextTag n = if n < 0 then ~ n else ~ (n + 1);
    
  (* We use this version if all the constructors are nullary (i.e. constants)
     except possibly one.  The (at most one) unary constructor is represented
     by the boxed value and the nullary constructors by untagged integers. *)
  (* Note that "UnaryTupled 0" (which would arise as a result of a declaration of the
     form  datatype t = A of () | ... ) can't be represented as "UnboxedForm"
     because "{}" is represented as a short (unboxed) integer. *)
  fun chooseOptimisedRepr1 _ [] = []
    | chooseOptimisedRepr1 n (h :: t) = 
       case h of
         (Nullary,       name) =>
             createNullaryConstructor(EnumForm n, name) :: chooseOptimisedRepr1 (nextTag n) t
       | (UnaryGeneric,  name) =>
               createUnaryConstructor(BoxedForm, name) :: chooseOptimisedRepr1 n t
       | (UnaryFunction, name) =>
               createUnaryConstructor(UnboxedForm, name)  :: chooseOptimisedRepr1 n t
       | (UnaryTupled 0, name) =>
               createUnaryConstructor(BoxedForm, name)    :: chooseOptimisedRepr1 n t
       | (UnaryTupled _, name) =>
               createUnaryConstructor(UnboxedForm, name)  :: chooseOptimisedRepr1 n t

  (* We use this version there's more than 1 unary constructor. *)
  (* With this representation constructors of small tuples make tuples of
     size n+1 whose first word is the tag.  Nullary constructors are represented
     by single word objects containing the tag. *)
  fun chooseOptimisedRepr2 _ [] = []
    | chooseOptimisedRepr2 n (h :: t) = 
  let
    val repr = 
      case h of
        (Nullary,       name) => createNullaryConstructor(genConstForm n, name)
      | (UnaryGeneric,  name) => createUnaryConstructor(TaggedBox n, name)
      | (UnaryFunction, name) => createUnaryConstructor(TaggedBox n, name)
      | (UnaryTupled i, name) =>
            createUnaryConstructor(
                  if i <= 4 (*!maxPacking*) then TaggedTuple (n, i) else TaggedBox n, name)
  in
    repr :: chooseOptimisedRepr2 (nextTag n) t
  end;

    fun getTupleKind t =
      case t of
        LabelledType {recList = [{typeof=t', ...}], frozen = true, ...} =>
            (* Singleton records are always represented simply by the value. *)
          getTupleKind t'
      
      | LabelledType {recList, frozen = true, ...} =>
          UnaryTupled (length recList)
      
      | FunctionType _ => 
          UnaryFunction
    
      | TypeConstruction {value, args, ...} =>
          let
            val cons = pling value
        in
              (* We may have a type equivalence or this may be a datatype. *)
            if tcIsAbbreviation cons
            then getTupleKind (makeEquivalent(cons, args))
            else if sameTypeId (tcIdentifier cons, tcIdentifier refType)
            then UnaryGeneric (* A tuple ref is NOT the same as the tuple. *)
            else (* Datatype.  For the moment we only consider datatypes with a
                    single constructor since we want to find the width of the
                    tuple.  At present we simply return UnaryGeneric for all
                    other cases but it might be helpful to return a special
                    result when we have a datatype which we know will always
                    be boxed. *)
                case tcConstructors cons of
                    [Value{typeOf, class=Constructor{nullary=false, ...}, ...}] =>
                        (* This may be a polymorphic datatype in which case
                           we have to invert the constructor to find the base type.
                           e.g. we may have an instance (int*int) t where t was
                           declared as datatype 'a t = X of 'a .*)
                        getTupleKind(constructorResult(typeOf, args))
                |    _ => UnaryGeneric
        end
    
      | _ =>
          UnaryGeneric

  (* This now creates the functions as well as choosing the representation. *)
    fun chooseConstrRepr cs =
    let
        fun checkArgKind (name, EmptyType) = (Nullary, name)
         |  checkArgKind (name, argType) = (getTupleKind argType, name)
        val kinds = map checkArgKind cs;

        fun chooseRepr [(Nullary, name)]       = [createNullaryConstructor(UnitForm, name)]
        | chooseRepr [(UnaryGeneric, name)]  = [createUnaryConstructor(OnlyOne, name)]
        | chooseRepr [(UnaryFunction, name)] = [createUnaryConstructor(OnlyOne, name)]
        | chooseRepr [(UnaryTupled _, name)] = [createUnaryConstructor(OnlyOne, name)]
        | chooseRepr l =
        let
          val unaryCount = List.foldl(fn((Nullary, _), n) => n | (_,n) => n+1) 0 l
        in
          (* tags now allocated from 0 (SPF 22/10/94) *)
          if unaryCount <= 1
          then chooseOptimisedRepr1 0 l (* can save the box *)
          else chooseOptimisedRepr2 0 l (* can use tagged tuples *)
        end;

       in
        chooseRepr kinds
    end;
 
   (* RefForm, NilForm and ConsForm are only used for built-in types *)


(*****************************************************************************)
(*             Standard values and exceptions.                               *)
(*****************************************************************************)

    (* Build a datatype within the basis. *)
    fun buildBasisDatatype(tcName, tIdPath, tyVars, isEqType: bool,
            mkValConstrs: typeConstrs -> values list) =
    let
        (* Create a temporary datatype.  The "name" we put in here is usually the
           same as the type constructor name except for datatypes in the PolyML structure
           which have the PolyML prefix. *)
        val description = basisDescription tIdPath
        val id =
            makeBoundId(Local{addr = ref 0, level = ref 0}, 0 (* IdNumber*),
                isEqType, true, description, ([], EmptyType))
        val dtype = makeDatatypeConstr (tcName, tyVars, id, 0, [DeclaredAt inBasis]);
        (* Build the constructors. *)
        val valConstrs = mkValConstrs dtype
        (* The constructors have to be ordered as in genValueConstrs in PARSE_TREE. *)
        fun leq (Value{name=xname, ...}) (Value{name=yname, ...}) = xname < yname;
        val sortedConstrs = quickSort leq valConstrs;
        val () = tcSetConstructors(dtype, sortedConstrs)
        val addrs = ref 0
        fun mkAddrs() = ! addrs before (addrs := !addrs+1)
        (* Create the datatype.  Sets the address of the local in "id". *)
        val dtCode = createDatatypeFunctions([dtype], [isEqType], mkAddrs, 0)
        (* Compile and execute the code to build the functions and extract the result. *)
        val globalCode = genCode(mkEnv(dtCode @ [codeId(id, 0)]), [])()
        val newId = makeFreeId(Global globalCode, isEqType, description, ([], EmptyType))
        (* Finally copy the datatype to put in the code. *)
    in
        fullCopyDatatype(dtype, fn 0 => newId | _ => raise Subscript, "")
    end

    (* Nil and :: are used in parsetree for lists constructed
       using [ ... ] and are also used for initialisation. *)
    local
        fun makeConsAndNil listType =
        let
            val listTypeVars  = tcTypeVars listType;
            val alpha         = TypeVar(hd listTypeVars);
            val alphaList     = mkTypeConstruction ("list", listType, [alpha], [DeclaredAt inBasis]);
            val consType      = mkFunctionType (mkProductType [alpha, alphaList], alphaList);
            val nilConstructor  =
                mkGconstr ("nil", alphaList, createNullaryConstructor(NilForm, "nil"),  true, 2, [DeclaredAt inBasis]);
            val consConstructor =
                mkGconstr ("::",  consType,  createUnaryConstructor(ConsForm, "::"), false, 2, [DeclaredAt inBasis]);
        in
            [nilConstructor, consConstructor]
        end
    in
        val listType =
            buildBasisDatatype("list", "list",
                [makeTv (EmptyType, generalisable, false, false)], true, makeConsAndNil)
        val (nilConstructor, consConstructor) =
            case tcConstructors listType of
                [consC as Value{name="::", ...}, nilC as Value{name="nil", ...}] => (nilC, consC)
            |   _ => raise InternalError "nil and cons in wrong order"
    end

    local
        fun makeNoneAndSome optionType =
        let
            val optionTypeVars  = tcTypeVars optionType;
            val alpha         = TypeVar(hd optionTypeVars);
            val alphaOption   = mkTypeConstruction ("option", optionType, [alpha], [DeclaredAt inBasis]);
            val someType      = mkFunctionType (alpha, alphaOption);
            val noneConstructor  =
                mkGconstr ("NONE", alphaOption,
                    createNullaryConstructor(EnumForm 0, "NONE"),  true, 2, [DeclaredAt inBasis]);
            val someConstructor =
                mkGconstr ("SOME",  someType,
                    createUnaryConstructor(BoxedForm, "SOME"), false, 2, [DeclaredAt inBasis]);
        in
            [noneConstructor, someConstructor]
        end
    in
        val optionType =
            buildBasisDatatype("option", "option",
                [makeTv (EmptyType, generalisable, false, false)], true, makeNoneAndSome)
        val (noneConstructor, someConstructor) =
            case tcConstructors optionType of
                [noneC as Value{name="NONE", ...}, someC as Value{name="SOME", ...}] => (noneC, someC)
            |   _ => raise InternalError "NONE and SOME in wrong order"
    end

    (* Construct an exception identifier - This is a ref (so we can uniquely
         identify it) containing a print function for the type. *)
    fun mkExIden(ty, level) =
    let
        val makeSome = case someConstructor of Value { access, ...} => vaGlobal access
        val makeNone = case noneConstructor of Value { access, ...} => vaGlobal access
        val printerCode =
            case ty of
                FunctionType { arg, ...} =>
                    mkEval(mkInd(1, makeSome), [printerForType(arg, level)], true)
            |   _ => mkInd(1, makeNone)
    in
        refApplyCode printerCode
    end

    (* Locations in exception packets.  In order to have a defined ordering of the fields,
       when we put the location in an exception packet we use this datatype rather than
       the "location" type. *)
     (* *)
    datatype RuntimeLocation =
        NoLocation
    |   SomeLocation of
            (* file: *) string * 
            (*startLine:*) int *  (*startPosition:*) int *
            (*endLine:*) int * (*endPosition:*) int

    fun codeLocation({file="", startLine=0, startPosition=0, ...}) =
        mkConst(toMachineWord NoLocation) (* No useful information *)
    |   codeLocation({file, startLine, startPosition, endLine, endPosition}) =
        mkConst(toMachineWord(file, startLine, startPosition, endLine, endPosition))

(*****************************************************************************)
  (* Look-up functions. *)

    (* Look up a structure. *)
    fun lookupStructure (kind, {lookupStruct:string -> structVals option},
               name, errorMessage) =
    let
        val {first = prefix, second = suffix} = splitString name;
        val strLookedUp =
            if prefix = ""
            then lookupStruct suffix
            else
            let  (* Look up the first part in the structure environment. *)
                val str =
                    lookupStructure
                        ("Structure", {lookupStruct=lookupStruct}, prefix, errorMessage);
            in 
                if isUndefinedStruct str
                then SOME undefinedStruct (* Error somewhere else? *)
                else 
                let
                    val Signatures { tab, typeIdMap, minTypes, maxTypes, ... } = structSignat str
                    val Env{lookupStruct, ...} = makeEnv tab
                    (* If we have a DeclaredAt location for the structure use this as the StructureAt.*)
                    val baseLoc =
                    case List.find (fn DeclaredAt _ => true | _ => false) (structLocations str) of
                        SOME (DeclaredAt loc) => [StructureAt loc]
                    |   _ => []
                in
                    case lookupStruct suffix of
                        SOME structFound =>
                        let
                            val Signatures { name, tab, typeIdMap = childMap, declaredAt, ... } = structSignat structFound
                            (* We need to apply the map from the parent structure to the child. *)
                            val copiedSig =
                                makeSignature(name, tab, minTypes, maxTypes, declaredAt, composeMaps(childMap, typeIdMap), [])
                            (* Convert Formal access to Selected and leave the others (Global?). *)
                            val newAccess =
                                case structAccess structFound of
                                    Formal sel => makeSelected (sel, str)
                                |   access => access
                            
                            val newStruct =
                                Struct { name = structName structFound, signat = copiedSig,
                                         access = newAccess, locations = baseLoc @ structLocations structFound}
                        in
                            SOME newStruct
                        end
                    |   NONE => NONE
                end
            end
    in
        case strLookedUp of
           SOME s => s
        |  NONE =>
             (* Not declared? *)
                (errorMessage (kind ^ " (" ^ suffix ^  ") has not been declared" ^
                   (if prefix = "" then "" else " in structure " ^ prefix));
                undefinedStruct)
    end;

    fun mkEnv x = let val Env e = makeEnv x in e end

    (* Look up a structure but ignore the access. This is used in sharing constraints
       where we're only interested in the signature. *)
    (* It's simpler to use the common code for this. *)
    fun lookupStructureAsSignature (lookupStruct, name, errorMessage) =
        lookupStructure("Structure", { lookupStruct = lookupStruct}, name, errorMessage)

    (* Look up a value, possibly in a structure. If it is in
       a structure we may have to apply a selection. *)
    fun lookupValue (kind, {lookupVal,lookupStruct}, name, errorMessage) =
    let
        val {first = prefix, second = suffix} = splitString name;
        val found =
        if prefix = "" then lookupVal suffix
        else
        let (* Look up the first part in the structure environment. *)
            val baseStruct =
                lookupStructure
                    ("Structure", {lookupStruct=lookupStruct}, prefix, errorMessage);
        in
            (* If the structure is not there the value can't be. *)
            if isUndefinedStruct baseStruct
            then SOME undefinedValue
            else
            let
                val Signatures { tab, typeIdMap, ...} = structSignat baseStruct
                (* If we have a DeclaredAt location for the structure use this as the StructureAt.*)
                val baseLoc =
                    case List.find (fn DeclaredAt _ => true | _ => false) (structLocations baseStruct) of
                        SOME (DeclaredAt loc) => [StructureAt loc]
                    |   _ => []
            in
                case #lookupVal (mkEnv tab) suffix of
                    SOME (Value{ name, typeOf, access, class, locations, ... }) =>
                    let
                        fun copyId(TypeId{idKind=Bound{ offset, ...}, ...}) = SOME(typeIdMap offset)
                        |   copyId _ = NONE
                        val copiedType =
                            copyType (typeOf, fn x => x,
                                fn tcon =>
                                    copyTypeConstr (tcon, copyId, fn x => x, fn s => prefix^"."^s))                            
                    in
                        SOME(mkSelectedVar (
                                Value{ name=name, typeOf=copiedType, access=access, class=class, locations=locations,
                                       references = NONE },
                                baseStruct, baseLoc))
                    end
                |   NONE => NONE
            end
        end
    in
        case found of
            SOME v => v
        |   NONE => (* Not declared? *)
            (
                errorMessage (kind ^ " (" ^ suffix ^ ") has not been declared" ^
                    (if prefix = "" then "" else " in structure " ^ prefix));
                undefinedValue
            )
    end

    fun lookupTyp ({lookupType,lookupStruct}, name, errorMessage) =
    let
        val {first = prefix, second = suffix} = splitString name;
        val found =
        if prefix = "" then lookupType suffix
        else
        let (* Look up the first part in the structure environment. *)
            val str =
                lookupStructure
                    ("Structure", {lookupStruct=lookupStruct}, prefix, errorMessage);
        in
            (* If the structure is not there the value can't be. *)
            if isUndefinedStruct str
            then SOME undefType
            else
            let
                val Signatures { tab, typeIdMap, ...} = structSignat str
            in
                case #lookupType (mkEnv tab) suffix of
                    SOME typeConstr => SOME(fullCopyDatatype(typeConstr, typeIdMap, prefix^"."))
                |   NONE => NONE
            end
        end
    in
        case found of
            SOME v => v
        |   NONE => (* Not declared? *)
            (
                errorMessage ("Type constructor" ^ " (" ^ suffix ^ ") has not been declared" ^
                (if prefix = "" then "" else " in structure " ^ prefix));
                undefType
            )
    end 

 
      (* Printing. *)

    (* This name space is used to help find type identifiers.
       However, because the functions are passed through to the resulting environment
       by INITIALISE we have to use the same type as the normal top-level environment. *)
    type nameSpace =
      { 
        lookupVal:    string -> values option,
        lookupType:   string -> typeConstrs option,
        lookupFix:    string -> fixStatus option,
        lookupStruct: string -> structVals option,
        lookupSig:    string -> signatures option,
        lookupFunct:  string -> functors option,

        enterVal:     string * values      -> unit,
        enterType:    string * typeConstrs -> unit,
        enterFix:     string * fixStatus   -> unit,
        enterStruct:  string * structVals  -> unit,
        enterSig:     string * signatures  -> unit,
        enterFunct:   string * functors    -> unit,

        allVal:       unit -> (string*values) list,
        allType:      unit -> (string*typeConstrs) list,
        allFix:       unit -> (string*fixStatus) list,
        allStruct:    unit -> (string*structVals) list,
        allSig:       unit -> (string*signatures) list,
        allFunct:     unit -> (string*functors) list
      };

  val nullEnvironment : nameSpace =
     {
        lookupVal = fn _ => NONE,
        lookupType = fn _ => NONE,
        lookupFix = fn _ => NONE,
        lookupStruct = fn _ => NONE,
        lookupSig = fn _ => NONE,
        lookupFunct = fn _ => NONE,
        enterVal = fn _ => (),
        enterType = fn _ => (),
        enterFix = fn _ => (),
        enterStruct = fn _ => (),
        enterSig = fn _ => (),
        enterFunct = fn _ => (),
        allVal = fn () => [],
        allType = fn () => [],
        allFix = fn () => [],
        allStruct = fn () => [],
        allSig = fn () => [],
        allFunct = fn () => []
        }

    (* Print a value given its type. *)
    fun printValueForType (value:machineWord, types, depth): pretty =
    let
        (* Constuct printer code applied to the argument and the depth.
           Code-generate and evaluate it. *)
        val printerCode =
            mkEval(
                printerForType(types, 0),
                [mkTuple[mkConst value, mkConst(toMachineWord depth)]],
                false)
        val pretty = RunCall.unsafeCast(evalue(genCode(printerCode, [])()))
    in
        pretty
    end

    fun displayFixStatus Nonfix = PrettyString "nonfix"
    | displayFixStatus (Infix prec) =
        PrettyBlock(0, false, [],
            [ PrettyString "infix", PrettyBreak (1, 0), PrettyString (Int.toString prec) ])
    | displayFixStatus (InfixR prec) =
        PrettyBlock(0, false, [],
            [ PrettyString "infixr", PrettyBreak (1, 0), PrettyString (Int.toString prec) ])

    (* Returns the declaration location as the location for the context. *)
    fun getLocation locations =
        case List.find(fn DeclaredAt _ => true | _ => false) locations of
            SOME(DeclaredAt loc) => [ContextLocation loc]
        |   _ => []


    (* displays value as a block, with no external formatting *)
    fun displayValues (Value{name, typeOf, class, access, locations, ...}, depth, nameSpace, sigMap): pretty =
    let
        (* Create the "val X =" part. *)
        fun valPart equOrColon =
            PrettyBlock (0, false, [],
                [
                    PrettyString "val",
                    PrettyBreak (1, 0),
                    PrettyBlock(0, false, getLocation locations, [PrettyString name]),
                    PrettyBreak (1, 0),
                    PrettyString equOrColon
                ]
            )
        val typeEnv = (* Environment to check for type constructors. *)
            { lookupType = #lookupType nameSpace, lookupStruct = #lookupStruct nameSpace}
    in
  
        if depth <= 0 
        then PrettyString "..."

        else
        case (class, access) of
        (SimpleValue, Global code) => (* Normal top-level values *)
             PrettyBlock (3, false, [],
                [
                    valPart "=",
                    PrettyBreak (1, 0),
                    printValueForType (evalue code, typeOf, depth),
                    PrettyBreak (1, 0),
                    PrettyBlock (3, false, [],
                        [ PrettyString ":", PrettyBreak (1, 3), displayWithMap (typeOf, depth, typeEnv, sigMap) ])
                 ])

        |    (SimpleValue, _) => (* Values in structures and overloaded values (from PolyML). *)
                (* We can't get a value to print in this case. *)
             PrettyBlock (3, false, [],
                [ valPart ":", PrettyBreak (1, 0), displayWithMap (typeOf, depth, typeEnv, sigMap) ])

        |    (Exception, _) => (* exceptions *)
             PrettyBlock (0, false, [],
                PrettyBlock (0, false, [],
                    [
                        PrettyString "exception",
                        PrettyBreak (1, 0),
                        PrettyBlock(0, false, getLocation locations, [PrettyString name])
                    ]
                )
                ::
                (
                    case getFnArgType typeOf of
                       NONE => []
                    |  SOME excType =>
                        [ PrettyBreak (1, 1), PrettyString "of", PrettyBreak (1, 3), displayWithMap (excType, depth, typeEnv, sigMap) ]
                )
            )
      
        | _ => PrettyString "" (* ??? *)
    end;

  (* Print global values.  This is passed through the bootstrap and used in the debugger. *)
  fun printValues (Value{typeOf, class, access, ...}, depth, _) =
        case (class, access) of
            (SimpleValue, Global code) => printValueForType (evalue code, typeOf, depth)
        | _ => PrettyString "" (* Probably shouldn't occur. *)

    (* Prints "sig ... end" as a block, with no external formatting *)
    fun displaySig (Signatures{tab, typeIdMap, ...}, depth : int, _ : int,
                    { lookupType, lookupStruct, ...}, sigMap: (int-> typeId) option) : pretty =
    let
        (* Construct an environment for the types. *)

        val Env { lookupType = strType, lookupStruct = strStr, ...} = makeEnv tab

        (* Construct a map for types. *)
        val innerMap =
            case sigMap of
                NONE => SOME typeIdMap
            |   SOME outerMap => SOME(composeMaps(typeIdMap, outerMap))

        val compositeEnv =
        {
            lookupType   =
                fn s => case strType s of NONE => lookupType s | SOME t => SOME (t, innerMap),
            lookupStruct =
                fn s => case strStr s of NONE => lookupStruct s | SOME s => SOME (s, innerMap)
        }
        
        val typeEnv: printTypeEnv =
            { lookupType = #lookupType compositeEnv, lookupStruct = #lookupStruct compositeEnv }

        fun displaySpec (_, value) : pretty list =
        if (tagIs signatureVar value)
        then (* Not legal ML97 *)
            [ PrettyBreak(1,2), displaySignatures (tagProject signatureVar value, depth - 1, compositeEnv)]
           
        else if (tagIs structVar value)
        then
            [ PrettyBreak(1,2), displayStructures (tagProject structVar value, depth - 1, compositeEnv, innerMap)]
               
        else if (tagIs typeConstrVar value)
        then 
            [ PrettyBreak(1,2), displayTypeConstrsWithMap (tagProject typeConstrVar value, depth, typeEnv, innerMap) ]
      
        else if (tagIs valueVar value)
        then
        let
            (* Only print variables. Constructors are printed with their type. *)
            val value = tagProject valueVar value;
        in
            case value of
                Value{class = Constructor _, ...} => []
            |    _ =>
              [ PrettyBreak(1,2),
              (* We lookup the infix status and any exception in the global environment
                 only.  Infix status isn't a property of a structure and it's too
                 much trouble to look up exceptions in the structure. *)
                displayValues (value, depth, compositeEnv, innerMap)
              ]
        end
      
        else if (tagIs fixVar value)
        then  (* Not legal ML97 *)
            [ PrettyBreak(1,2), displayFixStatus (tagProject fixVar value) ]
 
        else []
       (* end displaySpec *)
    in
        PrettyBlock (2, true, [],
            PrettyString "sig" ::
            (
                (
                    if depth <= 1 (* If the depth is 1 each of the calls to displaySpec will
                                     print "..." so we replace them all by a single "..." here. *)
                    then [PrettyBreak (1, 0), PrettyString "..."]
                    else
                    let
                        val declist = ref nil : (string * universal) list ref
                        fun addToList nv = declist := nv :: !declist
                        (* For the moment order them by name.  We may change this to
                           order primarily by kind and secondarily by name. *)
                        fun order (s1: string, _) (s2: string, _) = s1 <= s2
                    in
                        (* Put all the entries into a list. *)
                        for (univOver tab) addToList;
                        (* Sort the list and print it. *)
                        List.foldl
                            (fn (a, l) => displaySpec a @ l)
                            [] (quickSort order (!declist))
                    end
                )
                @ [PrettyBreak (1, 0), PrettyString "end"]
            )
        )
        end (* displaySig *)

  (* Print: signature S = sig .... end *)
  and displaySignatures (str, depth : int, nameSpace) : pretty =
    if depth <= 0 then PrettyString "..."
    else
        PrettyBlock(0, false, [],
            [
                PrettyBlock(0, false, [],
                    [
                        PrettyString "signature",
                        PrettyBreak(1, 0),
                        PrettyBlock(0, false,
                            [ContextLocation(sigDeclaredAt str)],
                            [PrettyString(sigName str)]
                        ),
                        PrettyBreak(1, 0),
                        PrettyString "="
                    ]
                ),
            PrettyBreak (1, 2),
            displaySig (str, depth, 1, nameSpace, NONE)
            ])

  (* print structure in a block (no external spacing) *)
    and displayStructures (str, depth, nameSpace, sigMap): pretty =
    if depth <= 0 then PrettyString "..."
    else if isUndefinedStruct str then PrettyString "<bad>"
    else
    let
        val structureName = structName str;
    in
        PrettyBlock (0, false, [],
        [
            PrettyBlock(0, false, [],
                [
                    PrettyString "structure",
                    PrettyBreak(1, 0),
                    PrettyBlock(0, false,
                        getLocation(structLocations str),
                        [PrettyString structureName]
                    ),
                    PrettyBreak(1, 0),
                    PrettyString ":"
                ]
            ),
            PrettyBreak(1, 2),
            displayNamedSig(structSignat str, depth - 1, 1, nameSpace, sigMap)
        ])
    end

    (* Internal function for printing structures and functors.  If a signature has a
       name print the name rather than the contents. *)
    and displayNamedSig(sign as Signatures{name = "", ...}, depth, space, nameSpace, sigMap) =
            displaySig (sign, depth, space, nameSpace, sigMap)
    |   displayNamedSig(Signatures{name, ...}, _, _, _, _) = PrettyString name

    fun displayFunctors (funct, depth, nameSpace) =
    if depth <= 0 then PrettyString "..."
    else
        PrettyBlock (0, false, [],
            PrettyBlock(0, false, [],
                [
                    PrettyString "functor",
                    PrettyBreak(1, 0),
                    PrettyBlock(0, false,
                        [ContextLocation(functorDeclaredAt funct)],
                        [PrettyString(functorName funct)]
                    ),
                    PrettyBreak(1, 0),
                    PrettyString "("
                ]) ::
            PrettyBreak(0, 2) ::
            let
                val arg = functorArg funct
                val argName = structName arg
            in
                (if argName <> ""
                then [ PrettyString(argName ^ " :"), PrettyBreak(1, 2) ]
                else []) @
                [
                    displayNamedSig (structSignat arg, depth - 1, 0, nameSpace, NONE),
                    PrettyString ") :",
                    PrettyBreak(1, 2),
                    let
                        (* Include the argument structure name in the type environment. *)
                        val argEnv =
                            if argName = ""
                            then
                            let
                                val Env { lookupType=lt, lookupStruct=ls, ...} =
                                    makeEnv(sigTab(structSignat arg))
                            in
                                {
                                    lookupType =
                                        fn s => case lt s of NONE => #lookupType nameSpace s | SOME t => SOME(t, NONE),
                                    lookupStruct =
                                        fn s => case ls s  of NONE => #lookupStruct nameSpace s | SOME s => SOME(s, NONE)
                                }
                            end
                            else
                            {
                                lookupType   = #lookupType nameSpace,
                                lookupStruct =
                                    fn s => if s = argName then SOME(arg, NONE) else #lookupStruct nameSpace s
                            }
                    in
                        displayNamedSig (functorResult funct, depth - 1, 1, argEnv, NONE)
                    end
                ]
            end
        )

    (* Exported version. *)
    val displayValues = fn (value, depth, nameSpace) => displayValues (value, depth, nameSpace, NONE)
    and displayStructures = fn (str, depth, nameSpace) => displayStructures (str, depth, nameSpace, NONE)
   
  (* Code-generation. *)

     (* Code-generate the values. *) 
 fun codeStruct (str, level) =
     (* Global structures have no code value. Instead the
        values are held in the values of the signature. *)
   if isUndefinedStruct str
   then CodeNil
   else codeAccess (structAccess str, level)

 and codeAccess (Global code, _) = code
      
 |  codeAccess (Local{addr=ref locAddr, level=ref locLevel}, level) =
     let
       val levelDiff = level - locLevel;
     in
       if locAddr = 0
       then mkRecLoad (levelDiff - 1)   (* Recursive *)
       else mkLoad (locAddr, levelDiff) (* Argument or local *)
     end
     
 | codeAccess (Selected{addr, base}, level) = (* Select from a structure. *)
       mkInd (addr, codeStruct (base, level))
     
 | codeAccess _ = raise InternalError "No access"
     (* codeAccess *);

(*****************************************************************************)
(*                  datatype access functions                                *)
(*****************************************************************************)

    (* Get the appropriate instance of an overloaded function.  If the
       overloading has not resolved to a single type it finds the preferred
       type if possible (i.e. int for most overloadings, but possibly real,
       word, string or char for conversion functions.) *)
    fun getOverloadInstance(name, instance, isConv): codetree*string =
    let
        val constr = typeConstrFromOverload(instance, isConv)
    in
        (getOverload(name, constr, fn _ => raise InternalError "getOverloadInstance: Missing"), tcName constr)
    end

    (* This is only used in addPrettyPrint and install_pp.  There's no point in
       producing a lot of detailed information. *)
    fun checkPPType (instanceType, matchType, fnName, lex, location, moreInfo) =
        case unifyTypes (instanceType, matchType) of
            NONE => ()
        |   SOME error =>
            let
                open DEBUG
                val parameters = LEX.debugParams lex
                val errorDepth = getParameter errorDepthTag parameters
            in
                reportError lex
                {
                    location = location,
                    hard = true,
                    message =
                        PrettyBlock(0, true, [],
                            [
                                PrettyString ("Argument for " ^ fnName),
                                PrettyBreak (1, 3),
                                PrettyBlock(0, false, [],
                                    [
                                        PrettyString "Required type:",
                                        PrettyBreak (1, 0),
                                        display (matchType, errorDepth, emptyTypeEnv)
                                    ]),
                                PrettyBreak (1, 3),
                                PrettyBlock(0, false, [],
                                    [
                                        PrettyString "Argument type:",
                                        PrettyBreak (1, 0),
                                        display (instanceType, errorDepth, emptyTypeEnv)
                                    ]),
                                PrettyBreak (1, 3),
                                unifyTypesErrorReport(lex, emptyTypeEnv, emptyTypeEnv, "unify") error
                            ]),
                    context = SOME (moreInfo ())
               }
            end;

 (* Code-generate an identifier matched to a value.  N.B. If the value is a
    constructor it returns the pair or triple representing the functions on the
    constructor. *)
 fun codeVal (Value{access = Global code, ...}, _, _, _, _) = code

  |  codeVal (Value{access = Local{addr=ref locAddr, level=ref locLevel}, ...}, level, _, _, _) =
     let
       (* Load the variable. *)
       val levelDiff = level - locLevel;
     in
       if locAddr = 0
       then mkRecLoad (levelDiff - 1)   (* Recursive *)
       else mkLoad (locAddr, levelDiff) (* Argument or local *)
     end

  |  codeVal (Value{access = Selected{addr, base}, ...}, level, _, _, _) =
       (* Select from a structure. *)
       mkInd (addr, codeStruct (base, level))

  |  codeVal (Value{access = Formal _, ...}, _, _, _, _) =
          raise InternalError "codeVal - Formal"

  |  codeVal (Value{access = Overloaded Print, ...}, level, instance, lex, _) =
        let 
            (* "instance" should be 'a -> 'a. We need to get the 'a. *)
            val argType = case getFnArgType instance of NONE => badType | SOME t => t;
            open DEBUG
            (* The parameter is the reference used to control the print depth
               when the value is actually printed. *)
            val printDepthFun = getParameter printDepthFunTag (LEX.debugParams lex)
            and prettyOut = getPrintOutput (LEX.debugParams lex)
        in
            (* Construct a function that gets the print code, prints it out and returns
               its argument. *)
            mkProc(
                CODETREE.mkEnv
                [
                    mkEval(
                        mkConst(toMachineWord prettyOut),
                        [
                            mkEval(
                                printerForType(argType, level+1),
                                [
                                    mkTuple[arg1,
                                        mkEval(mkConst(toMachineWord printDepthFun), [CodeZero], false)]
                                ],
                                false)
                        ],
                        false),
                    arg1 (* Returns its argument. *)
                ],
                level, 1, "print()")
        end 

  |  codeVal (Value{access = Overloaded MakeString, ...}, level, instance, _, _) =
        let 
            (* "instance" should be 'a -> string. We need to get the 'a. *)
            val argType = case getFnArgType instance of NONE => badType | SOME t => t;
        in
            (* Construct a function that gets the print code and prints it out using "uglyPrint". *)
            mkProc(
                mkEval(
                    mkConst(toMachineWord uglyPrint),
                    [
                        mkEval(
                            printerForType(argType, level+1),
                            [
                                mkTuple[arg1, mkConst(toMachineWord 10000)]
                            ],
                            false)
                    ],
                    false),
                level, 1, "makestring()")
        end

  |  codeVal (Value{access = Overloaded GetPretty, ...}, level, instance, _, _) =
       let (* Get the pretty code for the specified argument. *)
         (* "instance" should be 'a * int -> pretty. We need to get the 'a.  *)
         val argType =
            case getFnArgType instance of
                SOME(LabelledType{recList=({typeof, ...} :: _), ...}) => typeof
            |   _ => badType
       in
            printerForType(argType, level)
       end

  |  codeVal (Value{access = Overloaded AddPretty, ...}, level, instance, lex, loc) =
        let 
         (* "instance" should be (int-> 'a -> 'b -> pretty) -> unit.
             We need to get the 'a and 'b.  This function installs a
             pretty printer against the type which matches 'b.
             The type 'a is related to type of 'b as follows:
             If 'b is a monotype t then 'a is ignored.
             If 'b is a unary type constructor 'c t then 'a must have
             type 'c * int -> pretty.
             If 'b is a binary or higher type constructor e.g. ('c, 'd, 'e) t
             then 'a must be a tuple of functions of the form
             ('c * int -> pretty, 'd * int -> pretty, 'e * int -> pretty).
             When the installed function is called it will be passed the
             appropriate argument functions which it can call to print the
             argument types.  *)
            val argPrints  = mkTypeVar (generalisable, false, false);
            val installType   = mkTypeVar (generalisable, false, false);
            val pretty = mkTypeVar (generalisable, false, false);
            (* Build a pattern type and unify it to get the type variables.
               Unification should not fail here because type checking has already
               been done by the time we get here. *)
            val addPPType =
                mkFunctionType(
                    mkFunctionType (TYPESTRUCT.intType,
                        mkFunctionType(argPrints, mkFunctionType(installType, pretty))),
                    TYPESTRUCT.unitType);
            val () = checkPPType(instance, addPPType, "addPrettyPrinter", lex, loc, fn () => PrettyString "");

            (* Find the last type constructor in the chain. We have to install
                 this against the last in the chain because type constructors in
                 different modules may be at different points in the chain. *)
              (* This does mean that it's not possible to install a
                 pretty printer for a type constructor rather than a datatype. *)
            fun followTypes (TypeConstruction{value, args, ...}) =
            let
                val constr = pling value
            in
                if not (tcIsAbbreviation constr)
                then SOME(tcIdentifier constr, constr, List.length args)
                else followTypes (makeEquivalent (constr, args))
            end
            |   followTypes (TypeVar tv) =
                (
                    case tvValue tv of
                        EmptyType => NONE (* Unbound type variable *)
                    |   t => followTypes t
                )
            |   followTypes _ = NONE;

            val constrId = followTypes installType
            
            val () =
                case constrId of
                    NONE => ()
                |   SOME (_, constr, arity) =>
                    let
                        (* Check that the function tuple matches the arguments of the type
                           we're installing for. *)
                        (* Each entry should be a function of type 'a * int -> pretty *)
                        fun mkFn arg = mkFunctionType(mkProductType[arg, TYPESTRUCT.intType], pretty)
                        (* Create non-unifiable type vars to ensure this is properly polymorphic. *)
                        val typeVars = List.tabulate(arity, fn _ => mkTypeVar (0, false, true))
                        val tupleType =
                            case typeVars of
                                [] => (* No arg so we can have anything here. *)
                                    mkTypeVar (generalisable, false, false)
                            |   [arg] => mkFn arg (* Just a single function. *)
                            |   args => mkProductType(List.map mkFn args)
                        val addPPType = mkFunctionType(argPrints, mkFunctionType(installType, pretty))
                        val testType = mkFunctionType(tupleType,
                            mkFunctionType(
                                mkTypeConstruction(tcName constr, constr, typeVars, [DeclaredAt loc]),
                                pretty))
                    in
                        checkPPType(addPPType, testType, "addPrettyPrint", lex, loc,
                            fn () =>
                                PrettyString "addPrettyPrint element functions must have type 'a * int -> pretty")
                    end;

            (* Only report the error when the function is run.  Because addPrettyPrint is
               contained in the PolyML structure we may compile a reference to a polymorphic
               version of this for the structure record.  It's replaced in the final structure
               by this version. *)
        in
            case constrId of
                SOME (typeId, _, _) =>
                    (* Generate a function that will set the "print" ref for the type to
                       the argument function. *)
                    mkProc(
                        mkEval(
                            mkConst (ioOp POLY_SYS_assign_word),
                            [mkInd(1, codeAccess(idAccess typeId, level+1)), CodeZero, arg1],
                            false), 1, 1, "addPP")
                  (*mkConst (toMachineWord (fn _ => ()))*)
            |   NONE =>
                    mkConst (toMachineWord
                        (fn _ => raise Fail "addPrettyPrint: The argument type was not a simple type construction"))
        end

  |  codeVal (Value{access = Overloaded InstallPP, ...}, _, instance, lex, loc) =
        let
         (* This is the old function to install a pretty printer.  It has
            been retained for backwards compatibility.
            Since it will eventually be removed there's not much point in
            avoiding duplication with the code for AddPretty. *)
         (* "instance" should be ((,,,) -> int-> 'a -> 'b -> unit) -> unit.
             We need to get the 'a and 'b.  This function installs a
             pretty printer against the type which matches 'b.
             The type 'a is related to type of 'b as follows:
             If 'b is a monotype t then 'a is ignored.
             If 'b is a unary type constructor 'c t then 'a must have
             type 'c * int -> unit.
             If 'b is a binary or higher type constructor e.g. ('c, 'd, 'e) t
             then 'a must be a tuple of functions of the form
             ('c * int -> unit, 'd * int -> unit, 'e * int -> unit).
             When the installed function is called it will be passed the
             appropriate argument functions which it can call to print the
             argument types.  *)
            val argPrints  = mkTypeVar (generalisable, false, false);
            val installType   = mkTypeVar (generalisable, false, false);
            (* Build a pattern type and unify it to get the type variables.
               Unification should not fail here because type checking has already
               been done by the time we get here. *)
            (* The first type variable matches the set of pretty-printer functions
               we pass in and isn't needed for type info. *)
            val installPPType =
                mkFunctionType(
                    mkFunctionType(mkTypeVar (generalisable, false, false),
                        mkFunctionType (TYPESTRUCT.intType,
                            mkFunctionType(argPrints,
                                mkFunctionType(installType, TYPESTRUCT.unitType)))),
                    TYPESTRUCT.unitType);
            val () = checkPPType(instance, installPPType, "install_pp", lex, loc, fn () => PrettyString "");

            (* Find the last type constructor in the chain. We have to install
                 this against the last in the chain because type constructors in
                 different modules may be at different points in the chain. *)
              (* This does mean that it's not possible to install a
                 pretty printer for a type constructor rather than a datatype. *)
            fun followTypes (TypeConstruction{value, args, ...}) =
            let
                val constr = pling value
            in
                if not (tcIsAbbreviation constr)
                then SOME(tcIdentifier constr, constr, List.length args)
                else followTypes (makeEquivalent (constr, args))
            end
            |   followTypes (TypeVar tv) =
                (
                    case tvValue tv of
                        EmptyType => NONE (* Unbound type variable *)
                    |   t => followTypes t
                )
            |   followTypes _ = NONE;

            val constrId = followTypes installType
            
            val () =
                case constrId of
                    NONE => ()
                |   SOME (_, constr, arity) =>
                    let
                        (* Check that the function tuple matches the arguments of the type
                           we're installing for. *)
                        (* Each entry should be a function of type 'a * int -> unit *)
                        fun mkFn arg = mkFunctionType(mkProductType[arg, TYPESTRUCT.intType], TYPESTRUCT.unitType)
                        (* Create non-unifiable type vars to ensure this is properly polymorphic. *)
                        val typeVars = List.tabulate(arity, fn _ => mkTypeVar (0, false, true))
                        val tupleType =
                            case typeVars of
                                [] => (* No arg so we can have anything here. *)
                                    mkTypeVar (generalisable, false, false)
                            |   [arg] => mkFn arg (* Just a single function. *)
                            |   args => mkProductType(List.map mkFn args)
                        val installPPType =
                            mkFunctionType(argPrints, mkFunctionType(installType, TYPESTRUCT.unitType))
                        val testType =
                            mkFunctionType(tupleType,
                                mkFunctionType(
                                mkTypeConstruction(tcName constr, constr, typeVars, [DeclaredAt loc]),
                                    TYPESTRUCT.unitType))
                    in
                        checkPPType(installPPType, testType, "install_pp", lex, loc,
                            fn () =>
                                PrettyString "install_pp element functions must have type 'a * int -> unit")
                    end;

            (* This is the type of the pretty-printer as seen by the user *)
            type pp =
                (* addString *)  (string -> unit) *
                (* beginBlock *) (int * bool -> unit) *
                (* break *)      (int * int -> unit) *
                (* endBlock *)   (unit -> unit);

            fun installPp (pprint:pp -> int -> machineWord -> machineWord -> unit) =
            case constrId of
                NONE => raise Fail "install_pp: The argument type was not a simple type construction"
            |   SOME (typeToInstallFor, _, tupleWidth) =>
                let
                    (* Convert the old imperative form into the new pretty datatype. *)
                    fun createPretty depth (elemFns: machineWord) (valToPrint: machineWord): pretty =
                    let
                        (* Result stack. This contains open Begins and also accumulates the result. *)
                        val resultStack = ref []
                        (* Add an entry to the top block in the stack. *)
                        fun addEntry p =
                            case ! resultStack of
                                [] => (* Nothing there so far. *)
                                    resultStack := [p]
                            |   PrettyBlock(i, b, c, l) :: tail  =>
                                    (* Add to current block. *)
                                    resultStack := PrettyBlock(i, b, c, l @ [p]) :: tail
                            |   _ => (* Something there but not a Begin. *)
                                    raise Fail "Missing Begin"
                        fun addString s =
                            addEntry(PrettyString s)
                        and beginBlock(i: int, b: bool) =
                            addEntry(PrettyBlock(i, b, [], []))
                        and break (i: int, j: int) : unit =
                            addEntry(PrettyBreak(i, j))
                        and endBlock () =
                            case ! resultStack of
                                [] => raise Fail "End found with no Begin"
                            |   hd :: tl =>
                                    (* Pop the current block from the stack and
                                       add it as an entry to the immediately containing block. *)
                                (
                                    resultStack := tl;
                                    addEntry hd
                                )

                        val processElement: machineWord =
                        (* This is the single function or tuple of functions to process
                           the elements when this is a polytype. e.g. for "int" if this
                           is "int list". *)
                        case tupleWidth of
                            0 => toMachineWord (* Not used for monotypes. *)
                                    (fn _ => raise Fail "Monotype has no type argument")
                        |   1 => toMachineWord (* Single argument polytypes e.g. list *)
                                    (fn (v, depth) => addEntry(RunCall.unsafeCast elemFns (v, depth)))
                        |   n => (* Polytypes of more than one type e.g. ('a, 'b) pair. *)
                            let (* We have to construct a tuple of functions each of which calls
                                   the corresponding function in the tuple that is passed in. *)
                                fun getElem n (v, depth) =
                                let
                                    val prettyFn =
                                        RunCall.unsafeCast(loadWord(toAddress elemFns, toShort n))
                                in
                                    addEntry(prettyFn(v, depth))
                                end
                                (* As with the print code in printConstruction we use CodeTree
                                   to create the tuple. *)
                                val fns = List.tabulate (n, fn n => mkConst(toMachineWord(getElem n)))
                            in
                                evalue (mkTuple fns)
                            end
                    in
                        pprint (addString, beginBlock, break, endBlock) depth processElement valToPrint;
                        case ! resultStack of
                            [] => PrettyBlock(0, false, [], [])
                        |   [one] => one
                        |   _ => raise Fail "Incorrect nesting of begin...end blocks"
                    end
                in
                    case idAccess typeToInstallFor of
                        Global code =>
                                unsafeCast(evalue(mkInd(1, code))) := createPretty
                        |   _ => () (* Do nothing silently at the moment. *)
                end (* installPp *)

        in
            mkConst (toMachineWord installPp)
        end

  |  codeVal (Value{access = Overloaded GetLocation, ...}, _, _, _, _) =
        (* This can't be used a value: It must be called immediately. *)
        let
            fun getLoc() =
                raise Fail "The special function PolyML.sourceLocation cannot be used as a value"
        in
            mkConst (toMachineWord getLoc)
        end

  |  codeVal (value as Value{access = Overloaded _, ...}, level, instance, lex, lineno) =
       (* AddOverload, Equal, NotEqual, TypeDep *)
         mkProc
           (applyFunction (value, arg1, level+1, instance, lex, lineno),
           level, 1, "")
     (* codeVal *)

 (* Some of these have a more efficient way of calling them as functions. *)
 and applyFunction (value as Value{class=Exception, ...}, argument, level, instance, lex, lineno) =
     let
       (* If we are applying it as a function we cannot be after the
          exception id, we must be constructing an exception packet. *)
       (* Get the exception id, put it in the packet with the exception name
          the argument and, currently, an empty location as the exception location. *)
         val exIden = codeVal (value, level, instance, lex, lineno);
     in
         mkTuple (exIden :: mkStr (valName value) :: argument :: [mkConst(toMachineWord NoLocation)])
     end

  | applyFunction(value as Value{class=Constructor _, ...},
                    argument, level, instance, lex, lineno) =
     let
        (* If this is a value constructor we need to get the construction
           function and use that. *)
         val constrTriple = codeVal (value, level, instance, lex, lineno);
     in
         (* Don't apply this "early".  It might be the ref constructor and that
           must not be applied until run-time.  The optimiser should take care
           of any other cases. *)
        mkEval (mkInd(1, constrTriple), [argument], false)
     end

  | applyFunction (value as Value{access = Overloaded oper, name = valName, ...},
                     argument, level, instance, lex, lineno) =
     (
       case oper of
             Equal =>
            (* See if we have a special implementation for equality on
               this type.  If not we have to fall back to the default
               structure equality. *)
            (* Note: the overloadings will normally be inline functions
               which will unwrap the argument tuple and so elide it away.
               structureEq, though, is passed here as a pointer to
               the code so no such optimisation is possible and we will
               always make a tuple which will then be unwrapped inside
               structureEq. Two solutions are possible: we could build
               structureEq into the RTS in which case it would take an
               argument pair (usually in registers) or we could write it
               in the prelude and set it as an overload with some special
               type so that getOverload would return it as the default. *)
            let
                (* The instance type is a function so we have to get the first argument. *)
                val code = equalityForType(firstArg instance, level)
            in
                mkEval (code, [argument], true) (* evaluate early *)
            end
        
        | NotEqual =>
            let
                (* Use the "=" function to provide inequality as well as equality. *)
                val code = equalityForType(firstArg instance, level)
                val isEqual =
                    mkEval (code, [argument], true) (* evaluate early *)
            in
                mkNot isEqual
            end
       
        | TypeDep =>
           let
             val (code, _) = getOverloadInstance(valName, instance, false)
           in
             mkEval (code, [argument], true) (* evaluate early *)
           end

       | AddOverload =>
           (* AddOverload is only intended for use by writers of library modules.
           It only does limited checking and should be regarded as "unsafe". *)
           let
        (* instance should be ('a->'b) -> string -> unit.  For overloadings
           on most functions (e.g. abs and +) we are looking for the 'a, which
           may be a pair, but in the case of conversion functions we want the 'b. *)
           (* rmvars removes type variables put on by unification. *)
            fun rmvars (TypeVar tv) = rmvars(tvValue tv)
             | rmvars t = t

            fun followTypes(TypeConstruction{value, args, ...}):typeConstrs =
                let
                    val constr = pling value
                in
                   if not (tcIsAbbreviation constr)
                   then if not (isFreeId(tcIdentifier constr))
                   then raise Fail "Cannot install an overload within a structure or functor"
                   else constr
                   else followTypes (makeEquivalent (constr, args))
                end
             | followTypes _ =
                     raise Fail "Invalid type (not a type construction) (addOverload)"

           (* In normal use the instance type would be a function and
              everything would be fine.  It is possible though that we
              might have something of the form val a = addOverload in
              which case we want to leave the error until runtime.  This
              particular case seems to happen as a result of open PolyML
              when PolyML contains addOverload. *)
           val (argType, resultType) =
               case rmvars instance of
                FunctionType{arg,...} =>
                (
                case arg of
                    (* We could do some checking of the type of the
                       function such as checking that we either have
                       something of the form t->t, t*t->t or t*t->bool
                       or string->t in the case of conversion functions.
                       It's probably not worth it since adding overloads
                       is only intended to be done by writers of libraries. *)
                    FunctionType{arg, result} =>
                        (
                        case (rmvars arg) of
                            LabelledType{recList=[{typeof, ...}, _], ...} =>
                                (rmvars typeof, rmvars result)
                          | t => (rmvars t, rmvars result)
                        )
                  | _ => (badType, badType)
                )
              | _ => (badType, badType)

            fun addOverloading (argCode: codetree) (name: string) =
                let
                    val typeToUse =
                        if size name > 4 andalso
                            String.substring(name, 0, 4) = "conv"
                        (* For conversion functions it's the result
                           type we're interested in. For everything
                           else it's the argument type. *)
                        then resultType
                        else argType
                    val tcons = followTypes typeToUse
                in
                    addOverload(name, tcons, argCode)
                end

            (* This function is used if we can't get the codetree at
               compile time. *)
            fun addOverloadGeneral (arg: machineWord) =
                addOverloading(mkConst arg)
        in
        (* This is messy but necessary for efficiency.  If we simply treat
           addOverload as a function we would be able to pick up the
           additional overloading as a pointer to a function.  Most overloads
           are small functions or wrapped calls to RTS functions and so
           we need to get the inline code for them. *)
           (
               (* evalue raises an exception if "argument" is not a constant,
                  or more usefully, a global value containing a constant and
                  possibly a piece of codetree to inline. *)
               evalue(argument);
               mkConst (toMachineWord (addOverloading argument))
           )
           handle SML90.Interrupt => raise SML90.Interrupt
             | _ =>
               mkEval (mkConst (toMachineWord addOverloadGeneral), [argument], false)
        end

      | GetLocation => (* Return the current location. *) mkConst(toMachineWord lineno)
        
      | _ => (* Print, MakeString, InstallPP *)
         (* Just call as functions. *) (* not early *)
            mkEval (codeVal (value, level, instance, lex, lineno), [argument], false)
            
     ) (* overloaded *)
     
  | applyFunction (value, argument, level, instance, lex, lineno) =
   (* Just call as functions. *)
       mkEval (codeVal (value, level, instance, lex ,lineno), [argument], false)
   (* end applyFunction *)

  (* If the exception is being used as a value we want an exception packet
     or a function to make a packet. If it is a nullary constructor make
     an exception packet now, otherwise generate a function to construct
     an exception packet. *)
 fun codeExFunction (value, level, instance, lex, lineno) =
    case getFnArgType(valTypeOf value) of (* N.B. Not "instance" *)
        NONE => applyFunction (value, CodeZero, level, instance, lex, lineno)
    |   SOME _ =>
            mkProc 
              (applyFunction (value, arg1, level + 1, instance, lex, lineno),
                1, 1, ""); (* shouldn't this function be in-lined??? SPF 20/10/94 *)

    (* Operations to compile code from the representation of a constructor. *)
    (* Code to test whether a value matches a constructor. *)
    fun makeGuard (value as Value{class=Constructor _, ...}, testing, level) =
        mkEval(mkInd(0, codeVal (value, level, emptyType, nullLex, location nullLex)),
            [testing], true)

    |   makeGuard (value as Value{class=Exception, ...}, testing, level) =
     (* Should only be an exception. Get the value of the exception identifier 
        and compare with the identifier in the exception packet. *)
     mkTestptreq 
        (mkInd (0, testing),
         codeVal (value, level, emptyType, nullLex, location nullLex))

    |   makeGuard _ = raise InternalError "makeGuard"

    (* Code to invert a constructor. i.e. return the value originally
    used as the argument. *)
    fun makeInverse(value as Value{class=Constructor{nullary=false, ...}, ...}, arg, level): codetree =
        mkEval(mkInd(2, codeVal (value, level, emptyType, nullLex, location nullLex)),
            [arg], false) (* NOT "early" - this may be the "ref" constructor. *)

    |  makeInverse(Value{class=Constructor{nullary=true, ...}, ...}, _, _): codetree =
        (* makeInverse is called even on nullary constructors.  Return zero to keep the
           optimiser happy. *) CodeZero

    |   makeInverse (Value{class=Exception, ...}, arg, _) =
      (* Exceptions. - Get the parameter from third word *) mkInd (2,arg)

    |   makeInverse _ = raise InternalError "makeInverse"

 (* Get the current overload set for the function and return a new
    instance of the type containing the overload set. *)
 fun overloadType(Value{typeOf, access = Overloaded TypeDep, name, ...}, isConv) =
     let
        fun getTypes [] = []
         |  getTypes ((t, _) :: l) = t :: getTypes l

    in
        generaliseOverload(typeOf, getTypes(getOverloads name), isConv)
    end

 |  overloadType(Value{typeOf, ...}, _) =  generalise typeOf

  (* True if the arguments are definitely the same exception.  Used in the
     match compiler to see if we can merge adjacent exception patterns.
     Unlike the constructors of a datatype we can't assume that having the
     same (short) name means that the exceptions are the same, we have to
     look at the address. *)
   fun isTheSameException(Value{access = Global aCode, ...},
                             Value{access = Global bCode, ...}) : bool =
        wordEq(evalue aCode, evalue bCode)
       
   |  isTheSameException(Value{access = Local{addr=ref aAddr, level=ref aLevel}, ...},
                            Value{access = Local{addr=ref bAddr, level=ref bLevel}, ...}) : bool =
        (* I don't like this. It assumes that the address and level have
           already been set. *)
        aAddr = bAddr andalso aLevel = bLevel

  |  isTheSameException _ = false (* Forget about "selected" for the moment. *)

    (* Types that can be shared. *)
    structure Sharing =
    struct
        type machineWord    = machineWord
        type lexan          = lexan
        type codetree       = codetree
        type types          = types
        type values         = values
        type structVals     = structVals
        type functors       = functors
        type valAccess      = valAccess
        type typeConstrs    = typeConstrs
        type signatures     = signatures
        type fixStatus      = fixStatus
        type univTable      = univTable
        type pretty         = pretty
        type locationProp   = locationProp
        type typeId         = typeId
        type typeVarForm    = typeVarForm
    end

end (* body of VALUEOPS *);


