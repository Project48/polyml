(*
    Original Poly version:
    Title:      Operations on type structures.
    Author:     Dave Matthews, Cambridge University Computer Laboratory
    Copyright   Cambridge University 1985

    3/6/94 SPF fixed bug in allowGeneralisation
    6/6/94 SPF fixed bug in match

    ML translation and other changes:
    Copyright (c) 2000
        Cambridge University Technical Services Limited

    Further development:
    Copyright (c) 2000-9 David C.J. Matthews

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.
    
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.
    
    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*)

functor TYPE_TREE (

(*****************************************************************************)
(*                  SYSTEM                                                   *)
(*****************************************************************************)
structure ADDRESS :
sig
    val wordEq: 'a * 'a -> bool
end;

(*****************************************************************************)
(*                  DEBUG                                                    *)
(*****************************************************************************)
structure DEBUG :
sig
    val errorDepthTag: int Universal.tag
    val getParameter :
       'a Universal.tag -> Universal.universal list -> 'a
end;

(*****************************************************************************)
(*                  LEX                                                      *)
(*****************************************************************************)
structure LEX : LEXSIG
    
(*****************************************************************************)
(*                  STRUCTVALS                                               *)
(*****************************************************************************)
structure STRUCTVALS : STRUCTVALSIG;
    
(*****************************************************************************)
(*                  UTILITIES                                                *)
(*****************************************************************************)
structure UTILITIES :
sig
  val mapTable: ('a * 'a -> bool) ->
                   {enter: 'a * 'b -> unit, lookup: 'a -> 'b option}
  val splitString:   string -> { first:string, second:string }
end;

(*****************************************************************************)
(*                  PRETTY                                                   *)
(*****************************************************************************)
structure PRETTY : PRETTYSIG

(*****************************************************************************)
(*                  MISC                                                     *)
(*****************************************************************************)
structure MISC :
sig
  exception InternalError of string;
  
  val lookupDefault : ('a -> 'b option) -> ('a -> 'b option) -> 'a -> 'b option
end;

(*****************************************************************************)
(*                  CODETREE                                                 *)
(*****************************************************************************)
structure CODETREE :
sig
  type codetree
  
  val CodeNil:          codetree;
  val isCodeNil:        codetree -> bool;
end;

(*****************************************************************************)
(*                  EXPORTTREE                                               *)
(*****************************************************************************)

structure EXPORTTREE: EXPORTTREESIG;

sharing LEX.Sharing = PRETTY.Sharing = EXPORTTREE.Sharing = STRUCTVALS.Sharing
      = CODETREE

) :  TYPETREESIG =

(*****************************************************************************)
(*                  TYPETREE functor body                                    *)
(*****************************************************************************)
struct
  open MISC;
  open PRETTY;
  
  open STRUCTVALS;
  open LEX;
  open UTILITIES;
  open CODETREE;
  open EXPORTTREE
  
  val badType : types = BadType;
  
  (* added 16/4/96 SPF *)
  fun sameTypeVar (TypeVar x, TypeVar y) = sameTv (x, y)
    | sameTypeVar _                      = false;

  
  fun isTypeVar          (TypeVar          _) = true
    | isTypeVar          _ = false;
     
  fun isFunctionType     (FunctionType     _) = true
    | isFunctionType     _ = false;

  fun isEmpty             EmptyType           = true
    | isEmpty            _ = false;
    
  fun isBadType           BadType             = true
    | isBadType          _ = false;

  val emptyType            = EmptyType;

  fun typesTypeVar          (TypeVar          x) = x 
    | typesTypeVar          _ = raise Match;
    
  fun typesTypeConstruction (TypeConstruction x) = x 
    | typesTypeConstruction _ = raise Match;
    
  fun typesFunctionType     (FunctionType     x) = x
     | typesFunctionType     _ = raise Match;

  (* A type construction is the application of a type constructor to
     a sequence of types to yield a type. A construction may have a nil
     list if it is a single type identifier such as ``int''. *)
  
  (* When a type constructor is encountered in the first pass this entry 
     is put in. Subsequently a type constructor entry will be assigned to
     it so that the types can be checked. *)

(*************)

    fun mkTypeVar (level, equality, nonunifiable) = 
        TypeVar (makeTv (emptyType, level, equality, nonunifiable));

    fun mkTypeConstruction (name, typc, args, locations) =
        TypeConstruction {name = name, value = FrozenRef typc,
                          args = args, locations = locations}

    local
        (* Turn a tuple into a record of the form {1=.., 2=... }*)
        fun maptoRecord ([], _) = []
          | maptoRecord (H::T, i) = 
                {name=Int.toString i, typeof=H} :: maptoRecord (T,i+1)
    in
        fun mkProductType (typel: types list) =
            LabelledType {recList = maptoRecord (typel, 1), frozen = true,
                          genericInstance = []}
    end

  fun mkFunctionType (arg, result) = 
      FunctionType {arg = arg, result = result};

  fun mkOverloadSet [constr] =
    (* If there is just a single constructor in the set we make
       a type construction from it. *)
        mkTypeConstruction(tcName constr, constr, nil, [])
   | mkOverloadSet constrs = 
    let
        (* Make a type variable and point this at the overload set
           so we can narrow down the overloading. *)
        val var = mkTypeVar (generalisable, false, false);
        val set = OverloadSet {typeset=constrs};
    in
        tvSetValue (typesTypeVar var, set);
        var
    end

  fun mkLabelled (l, frozen) = 
  let
    val lab = LabelledType {recList = l, frozen = frozen, genericInstance = []};
  in
    if frozen
    then lab
    else let (* Use a type variable so that the record can be expanded. *)
      val var = mkTypeVar (generalisable, false, false);
      val () =
        if isTypeVar var
        then tvSetValue (typesTypeVar var, lab)
        else ();
    in
      var
    end
  end;

    (* Must remove leading zeros because the labels are compared by
       string comparison. *)
    fun mkLabelEntry (name, t) = 
    let
        fun stripZeros s = 
            if size s <= 1  orelse String.str(String.sub(s, 0)) <> "0" 
            then s
            else stripZeros (String.substring(s, 1, size s-1));
    in
        {name = stripZeros name, typeof = t}
    end;

  (* Type identifiers bound to standard type constructors. *)
   
  val unitType = mkTypeConstruction ("unit", unitType, [], []);
   
  val intType    = mkTypeConstruction ("int",     intType,    [], []);
  val realType   = mkTypeConstruction ("real",    realType,   [], []);
  val charType   = mkTypeConstruction ("char",    charType,   [], []);
  val stringType = mkTypeConstruction ("string",  stringType, [], []);
  val boolType   = mkTypeConstruction ("bool",    boolType,   [], []);
  val exnType    = mkTypeConstruction ("exn",     exnType,    [], []);
  val wordType   = mkTypeConstruction ("word",    wordType,   [], []);
          
    fun isUndefined cons = sameTypeId (tcIdentifier cons, tcIdentifier undefType);
    val isUndefinedTypeConstr = isUndefined

    (* Test if a type is the undefined constructor. *)
    fun isUndefinedType(TypeConstruction{value, ...}) = isUndefined(pling value)
    |   isUndefinedType _ = false

    (* Similar to alphabetic ordering except that shorter labels come before longer ones.
       This has the advantage that numerical labels are compared by their numerical order
       i.e. 1 < 2 < 10 whereas alphabetic ordering puts "1" < "10" < "2". *)
    fun compareLabels (a : string, b : string) : int = 
    if size a = size b 
    then if a = b then 0 else if a < b then ~1 else 1
    else if size a < size b then ~1 else 1;

    (* Sort using the label ordering.
       A simple sort routine - particularly if the list is already sorted. *)
    fun sortLabels [] = []
    |   sortLabels (s::rest) =
    let
        fun enter s _    [] = [s]
          | enter s name (l as ( (h as {name=hname, ...}) :: t)) =
        let
            val comp = compareLabels (name, hname);
        in
            if comp <= 0 then s :: l else h :: enter s name t
        end;
    in  
        enter s (#name s) (sortLabels rest)
    end;        

  (* Chains down a list of type variables returning the type they are
     bound to. As a side-effect it also points all the type variables
     at this type to reduce the need for future chaining and to free
     unused type variables. Normally a type variable points to at most
     one other, which then points to "empty". However if we have unified
     two type variables by pointing one at the other, there may be type
     variables which pointed to the first and which cannot be found and
     redirected at the second until they themselves are examined. *)
     
  (* rewritten using pattern-matching SPF 17/11/94 *)
  fun eventual (t as (TypeVar tv)) : types =
    let
      (* Note - don't change the level/copy information - the only type
         variable with this correct is the one at the end of the list. *)
      val oldVal = tvValue tv
      val newVal = eventual oldVal;   (* Search that *)
    in
      (* Update the type variable to point to the last in the chain.
         We don't do this if the value hasn't changed.  The reason for
         that was that assignment to refs in the database in the old
         persistent store system was very expensive and we wanted to avoid
         unnecessary assignments.  This special case could probably be removed. *)
      if ADDRESS.wordEq(oldVal, newVal)
      then ()
      else tvSetValue (tv, newVal); (* Put it on *)
      case newVal of
        EmptyType => (* Not bound to anything - return the type variable *)
          t
      
      | LabelledType {frozen = false, recList = instanceList,
                      genericInstance = genericInstance as generic :: _} =>
        (* Flexible record type.  We need to add any fields which have been
           added to the generic since we extracted this instance.  In particular
           the generic might have been frozen. *)
        let
        fun createNewField{name, typeof = TypeVar gtv} =
            (
            (*print(concat[
                "createNewField:",
                "Generic - equality=", Bool.toString(tvEquality gtv),
                " level=", Int.toString(tvLevel gtv),
                " Instance - equality=", Bool.toString(tvEquality tv),
                " level=", Int.toString(tvLevel tv),
                "\n"
            ]);*)
            { name = name,
              (* The new type variable has to be created with the same properties
                 as if we had first generalised it from the generic and then
                 unified with this instance.
                 The level is inherited from the instance since the generic
                 will always have level = generalisable.  Nonunifiable must be false. *)
              typeof = mkTypeVar (tvLevel tv, tvEquality tv orelse tvEquality gtv, false)
            }
            )
        |   createNewField _ =  raise InternalError "createNewField: New field is not a type var"

        fun addToInstance([], []) = []
         |  addToInstance(generic :: geRest, []) = createNewField generic :: addToInstance(geRest, [])
         |  addToInstance([], _) =
                raise InternalError "addToInstance: Entry in instance but not in generic"
         |  addToInstance((generic as {name=gName, ...}):: geRest, inst as instance :: iRest) =
                let
                    val order = compareLabels (gName, #name instance);
                in
                    if order = 0 (* Equal *)
                    then instance :: addToInstance(geRest, iRest)
                    else if order < 0 (* generic name < instance name *)
                    then createNewField generic :: addToInstance(geRest, inst)
                    else raise InternalError "addToInstance: Entry in instance but not in generic"
                end

        val (newList, nowFrozen) = 
            case tvValue generic of
                LabelledType { recList, frozen, ... } =>
                    (addToInstance(recList, instanceList), frozen)
            |   _ => raise InternalError "unifyRecords: Not a labelled record"
        val newRecord =
            LabelledType {frozen = nowFrozen, genericInstance = genericInstance, recList = newList}
        in
            tvSetValue(tv, newRecord);
            if nowFrozen then newRecord else t
        end

      | LabelledType {frozen = false, ...} => t
        (* Flexible record with no generic instances - return the variable. *)

      | OverloadSet _ => (* Return the set of types. *)
          t

      | _ => 
          newVal (* Return the type it is bound to *)
    end
    
   | eventual t (* not a type variable *) = t;


  (* Apply a function to every element of a type. *)
  (* rewritten using pattern-matching SPF 17/11/94 *)
  fun foldType f =
  let
    fun foldT typ v =
    let
      val t   = eventual typ;
      val res = f t v; (* Process this entry. *)
    in
      case t of
        TypeVar tv =>
          foldT (tvValue tv) res

       | TypeConstruction {args, ...} =>
           (* Then process the arguments. *)
           List.foldr (fn (t, v) => foldT t v) res args
           
      | FunctionType {arg, result} =>
           foldT arg (foldT result res)
    
      | LabelledType {recList,...} =>
           List.foldr (fn ({ typeof, ... }, v) => foldT typeof v) res recList

      | BadType =>
          res
         
      | EmptyType =>
          res
          
      | OverloadSet _ => res
    end;
  in
    foldT
  end;
        
  (* Associates type constructors from the environment with type identifiers
    (NOT type variables) *)
  fun assignTypes
      (t : types, 
       lookupType : string * location -> typeConstrs, 
       lex : lexan) 
      : unit =
    let
        fun assTypes (typ : types) () : unit =
            case typ of
                TypeConstruction {name: string, value, args: types list, locations} =>
                (* Assign constructor, then the parameters. *)
                    if isUndefined (pling value)
                    then
                        let
                            val location =
                                case List.find(fn (DeclaredAt _) => true | _ => false) locations of
                                    SOME(DeclaredAt loc) => loc
                                |   _ => LEX.nullLocation
                        (* Must check that it has not already been set -
                           We might have unitType from an empty record. *)
                            val constructor : typeConstrs = lookupType (name, location);
                        in
                            updatePR(value, constructor);
                            (* Check that it has the correct arity. *)
                            if not (isUndefined constructor)
                            then
                            let
                                val arity : int = tcArity constructor;
                                val num   : int = length args;
                            in
                                if arity <> num
                                then (* Give an error message *)
                                errorMessage (lex, location,
                                    String.concat["Type constructor (", tcName constructor,
                                        ") requires ", Int.toString arity, " type(s) not ",
                                        Int.toString num])
                                else ()
                            end
                            else ()
                        end
                    else ()
            | _ => () (* not a TypeConstruction *)
    in (* Apply this to all the types. *)
        foldType assTypes t ()
    end;

  (* Checks to see whether a labelled record is in the form of
     a product i.e. 1=, 2=   We only need this for prettyprinting.
     Zero-length records (i.e. unit) and singleton records are not
     considered as tuples. *)
  fun isProductType(LabelledType{recList=recList as _::_::_, frozen=true, ...}) =
    let
        fun isRec [] _ = true
         |  isRec ({name, ...} :: l) n =
                name = Int.toString n andalso isRec l (n+1)
    in
        isRec recList 1
    end
    | isProductType _ = false;


    (* Test to see is a type constructor is in an overload set. *)
    fun isInSet(tcons: typeConstrs, (H::T): typeConstrs list) =
            sameTypeId (tcIdentifier tcons, tcIdentifier H) orelse isInSet(tcons, T)
    |   isInSet(_, []: typeConstrs list) = false

    (* Returns the preferred overload if there is one. *)
    fun preferredOverload typeset =
        if isInSet(STRUCTVALS.intType, typeset)
        then SOME STRUCTVALS.intType
        else if isInSet(STRUCTVALS.realType, typeset)
        then SOME STRUCTVALS.realType
        else if isInSet(STRUCTVALS.wordType, typeset)
        then SOME STRUCTVALS.wordType
        else if isInSet(STRUCTVALS.charType, typeset)
        then SOME STRUCTVALS.charType
        else if isInSet(STRUCTVALS.stringType, typeset)
        then SOME STRUCTVALS.stringType
        else NONE


    fun equalTypeIds(x, xMap, y, yMap) =
    let
        (* True if two types are equal. *)
        fun equalTypes (TypeConstruction{value=xVal, args=xArgs, ...},
                        TypeConstruction{value=yVal, args=yArgs, ...}) =
            (* The equivalents are as the result of mapping so we mustn't remap them. *)
            sameTypeId(tcIdentifier(pling xVal), tcIdentifier(pling yVal))
                andalso equalTypeLists (xArgs, yArgs)
    
        | equalTypes (FunctionType x, FunctionType y) = 
            equalTypes (#arg x, #arg y)   andalso 
            equalTypes (#result x, #result y)
                 
        | equalTypes (LabelledType x, LabelledType y) =
            #frozen x andalso #frozen y andalso  
            equalRecordLists (#recList x, #recList y)

        | equalTypes (TypeVar x, TypeVar y)  = sameTv (x, y)

        | equalTypes (EmptyType, EmptyType) = true

        | equalTypes _ = false
                              
        and equalTypeLists ([], [])    = true
        |   equalTypeLists (x::xs, y::ys) =
               equalTypes(x, y) andalso equalTypeLists (xs, ys)
        |   equalTypeLists _           = false

        and equalRecordLists ([],        [])    = true
        |   equalRecordLists (x::xs, y::ys) =
               #name x = #name y andalso 
               equalTypes(#typeof x, #typeof y) andalso equalRecordLists (xs, ys)
        |   equalRecordLists _             = false

        val mappedX as TypeId{typeFn=(_, xEquiv), ...} =
            case (xMap, x) of
                (SOME map, TypeId{idKind=Bound{offset, ...}, ...}) => map offset
            |   (_, id) => id
        val mappedY as TypeId{typeFn=(_, yEquiv), ...} =
            case (yMap, y) of
                (SOME map, TypeId{idKind=Bound{offset, ...}, ...}) => map offset
            |   (_, id) => id
    in
        (* If they are the same type ID they are the same type except in one
           case.  If they are actually type functions that started out in the
           same signature they will have the same (Free) type ID but may be
           equivalent to different types. *)
        sameTypeId(mappedX, mappedY) andalso equalTypes(xEquiv, yEquiv)
    end


    (* See if the types are the same. This is a bit of a fudge, but saves carrying
       around a flag saying whether the structures were copied. This is only an
       optimisation. If the values are different it will not go wrong. *)
    val identical : types * types -> bool = PolyML.pointerEq
    and identicalConstr : typeConstrs * typeConstrs -> bool = PolyML.pointerEq
    and identicalList : 'a list * 'a list -> bool = PolyML.pointerEq

    (* Copy a type, avoiding copying type structures unnecessarily.
       Used to make new type variables for all distinct type variables when
       generalising polymorphic functions, and to make new type stamps for
       type constructors when generalising signatures. *)
    fun copyType (at, copyTypeVar, copyTypeConstr) =
    let
        fun copyList [] = []
        |   copyList (l as (h :: t)) =
        let
            val h' = copyType (h, copyTypeVar, copyTypeConstr);
            val t' = copyList t;
        in
            if identical (h', h) andalso identicalList (t', t)
            then l
            else h' :: t'
        end  (* copyList *);

        fun copyRecordList [] = []
        |   copyRecordList (l as ({name, typeof} :: t)) =
        let
            val typeof' = copyType (typeof, copyTypeVar, copyTypeConstr);
            val t' = copyRecordList t;
        in
            if identical (typeof', typeof) andalso identicalList (t', t)
            then l
            else {name=name, typeof=typeof'} :: t'
        end  (* copyList *);

        val atyp = eventual at;
    in
        case atyp of
            TypeVar _ =>  (* Unbound type variable, flexible record or overloading. *)
                copyTypeVar atyp
    
        |   TypeConstruction {value, args, locations, ...} => 
            let
                val copiedArgs   = copyList args;
                val copiedConstr = copyTypeConstr (pling value);
                (* Use the name from the copied constructor.  This will normally
                   be the same as the original EXCEPT in the case where we are
                   using copyType to generate copies of the value constructors of
                   replicated datatypes. *)
                val copiedName = tcName copiedConstr
            in
                if identicalList   (copiedArgs, args) andalso
                    identicalConstr (copiedConstr, pling value)
                (* Although it's logically unnecessary we also copy it if we have
                   a ref pointing to the constructor.  This reduces the number of
                   refs left around. *)
                    andalso (case value of FrozenRef _ => true | _ => false)
                then atyp 
                else (* Must copy it. *) 
                    mkTypeConstruction (copiedName, copiedConstr, copiedArgs, locations)
            end 
           
        |   FunctionType {arg, result} => 
            let
                val copiedArg  = copyType (arg,    copyTypeVar, copyTypeConstr);
                val copiedRes  = copyType (result, copyTypeVar, copyTypeConstr);
            in
                if identical (copiedArg, arg) andalso 
                    identical (copiedRes, result)
                then atyp 
                else FunctionType {arg = copiedArg, result = copiedRes}
            end 
              
        |   LabelledType {recList, frozen, ...} =>
                (* Rigid labelled records only.  Flexible ones are treated as type vars. *)
            let
                val copiedList = copyRecordList recList;
            in
                if identicalList (copiedList, recList)
                then atyp 
                else LabelledType {recList = copiedList, frozen = frozen, genericInstance = []}
            end
                        
        |   EmptyType =>
                EmptyType

        |   BadType =>
                BadType
        
        |   OverloadSet _ =>
                raise InternalError "copyType: OverloadSet found"

    end (* copyType *);

    (* Copy a type constructor if it is Bound and in the required range.  If this refers to a type
       function copies that as well. Does not copy value constructors. *)
    fun copyTypeConstrWithCache (tcon, typeMap, _, mungeName, cache) =
        case tcIdentifier tcon of
            id as TypeId{typeFn=(_, EmptyType), ...} =>
            (
                case typeMap id of
                    NONE =>
                    (
                        (*print(concat[tcName tcon, " not copied\n"]);*)
                        tcon (* No change *)
                    )
                |   SOME newId =>
                    let
                        val name = #second(splitString (tcName tcon))
                        (* We must only match here if they're really the same. *)
                        fun cacheMatch tc =
                            equalTypeIds(tcIdentifier tc, NONE, newId, NONE)
                                andalso #second(splitString(tcName tc)) = name
                    in
                        case List.find cacheMatch cache of
                            SOME tc =>
                            (
                                (*print(concat[tcName tcon, " copied as ", tcName tc, "\n"]);*)
                                tc (* Use the entry from the cache. *)
                            )
                        |   NONE =>
                            (* Either a hidden identifier or alternatively this can happen as part of
                               the matching process.
                               When matching a structure to a signature we first match up the type
                               constructors then copy the type of each value replacing bound type IDs
                               with the actual IDs as part of the checking process.
                               We will return SOME newId but we don't have a
                               cache so return NONE for List.find. *)
                            let
                                val newName = mungeName(tcName tcon)
                            in
                                (*print(concat[tcName tcon, " not cached\n"]);*)
                                makeDatatypeConstr(newName,
                                    tcTypeVars tcon, newId, 0 (* Always global. *), tcLocations tcon)
                            end
                    end
            )

       |    TypeId{typeFn=(args, equiv), description, access, idKind, ...} =>
            let
                val copiedEquiv =
                    copyType(equiv, fn x => x,
                        fn tcon =>
                            copyTypeConstrWithCache (tcon, typeMap, fn x => x, mungeName, cache))
            in
                if identical (equiv, copiedEquiv)
                then tcon (* Type is identical and we don't want to change the name. *)
                else (* How do we find a type function? *)
                    if null (tcConstructors tcon)
                then (*makeTypeAbbreviation(tcName tcon, args, copiedEquiv, tcLocations tcon)*)
                    makeFrozenTypeConstrs (mungeName(tcName tcon), args,
                        TypeId {
                            access = access, description = description, idKind = idKind,
                            typeFn=(args, copiedEquiv)},
                        0, tcLocations tcon)

                else raise Misc.InternalError "localCopyTypeConstr: Well-formedness broken"
            end


    (* Exported version. *)
    fun copyTypeConstr (tcon, typeMap, copyTypeVar, mungeName) =
        copyTypeConstrWithCache(tcon, typeMap, copyTypeVar, mungeName, [])

    (* Compose typeID maps.  If the first map returns a Bound id we apply the second otherwise
       just return the result of the first. *)
    fun composeMaps(m1, m2) n =
    let
        fun map2 (TypeId{idKind=Bound{ offset, ...}, typeFn=(_, EmptyType), ...}) = m2 offset

        |   map2 (id as TypeId{idKind=Free _, typeFn=(_, EmptyType), ...}) = id

        |   map2 (TypeId{typeFn=(args, equiv), access, description, idKind, ...}) =
            let
                fun copyId(TypeId{idKind=Free _, ...}) = NONE
                |   copyId id = SOME(map2 id)
                (* If it's a type function e.g. this was a "where type" we have to apply the
                   map to any type identifiers in the type. *)
                val copiedEquiv =
                    copyType(equiv, fn x => x,
                        fn tcon => copyTypeConstr (tcon, copyId, fn x => x, fn y => y))
            in
                TypeId{typeFn=(args, copiedEquiv), access=access, description=description, idKind=idKind}
            end
    in
        map2(m1 n)
    end

    (* Basic procedure to print a type structure. *)
    type printTypeEnv =
        { lookupType: string -> (typeConstrs * (int->typeId) option) option,
          lookupStruct: string -> (structVals * (int->typeId) option) option}

    val emptyTypeEnv = { lookupType = fn _ => NONE, lookupStruct = fn _ => NONE }
  
    (* prints a block of items *)
    fun tDisp (t : types, depth : int, typeVarName : typeVarForm -> string, env: printTypeEnv,
               sigMap: (int->typeId)option) : pretty =
    let
        (* prints a block of items *)
        fun dispP (t : types, depth : int) : pretty =
        let
            (* prints a block of items *)
            fun parenthesise depth t =
            if depth <= 1
            then PrettyString "..."
            else
                PrettyBlock (0, false, [],
                    [
                        PrettyString "(",
                        PrettyBreak (0, 0),
                        dispP (t, depth - 1),
                        PrettyBreak (0, 0),
                        PrettyString ")"
                    ]);
    
            (* prints a sequence of items *)
            fun prettyList [] _ _: pretty list = []

            |   prettyList [H] depth separator =
                let
                    val v = eventual H;
                in
                    if separator = "*" andalso
                        (isFunctionType v orelse isProductType v)
                    then (* Must bracket the expression *) [parenthesise depth v]
                    else [dispP (v, depth)]
                end

            |   prettyList (H :: T) depth separator =
                if depth <= 0
                then [PrettyString "..."]
                else
                let
                    val v = eventual H;
                in
                    PrettyBlock (0, false, [],
                        [(if separator = "*" andalso
                           (isFunctionType v orelse isProductType v)
                        then (* Must bracket the expression *) parenthesise depth v
                        else dispP (v, depth)),
                        PrettyBreak (if separator = "," then 0 else 1, 0),
                        PrettyString separator
                        ]) ::
                    PrettyBreak (1, 0) ::
                    prettyList T (depth - 1) separator
                end;
        
            val typ = eventual t; (* Find the real type structure *)
        in 
            case typ of
                TypeVar tyVar =>
                let
                    val tyVal : types = tvValue tyVar;
                in
                    case tyVal of
                        EmptyType => PrettyString (typeVarName tyVar)
                    |   _         => dispP (tyVal, depth)
                end
      
                (* Type construction. *)
            |   TypeConstruction {args, name, value, ...} =>
                let
                    val typeConstructor = pling value
                    val constrName = (* Use the type constructor name unless we're had an error. *)
                        if isUndefined typeConstructor then name else tcName typeConstructor
                    
                    (* If we're printing a value that refers to a type constructor we
                       want to print the correct amount of any structure prefix for the
                       current context. *)
                    fun findType (_, []) = false
                    |   findType ({ lookupType, ... }, [typeName]) =
                        (
                            (* This must be the name of a type. *)
                            case lookupType typeName of
                                SOME (t, map) =>
                                    equalTypeIds(tcIdentifier typeConstructor, sigMap, tcIdentifier t, map)
                            |   NONE => false
                        )
                    |   findType ({ lookupStruct, ... }, structName :: tail) =
                        (
                            (* This must be the name of a structure.  Does it contain our type? *)
                            case lookupStruct structName of
                                SOME(str, map) =>
                                    let
                                        val Signatures { tab, typeIdMap, ...} = structSignat str
                                        val Env { lookupType, lookupStruct, ...} = makeEnv tab
                                        val newMap =
                                            case map of
                                                SOME map => composeMaps(typeIdMap, map)
                                            |   NONE => typeIdMap
                                        fun subLookupType s =
                                            case lookupType s of NONE => NONE | SOME t => SOME(t, SOME newMap)
                                        fun subLookupStruct s =
                                            case lookupStruct s of NONE => NONE | SOME t => SOME(t, SOME newMap)
                                    in
                                        findType({lookupType=subLookupType, lookupStruct=subLookupStruct}, tail)
                                    end
                            |   NONE => false
                        )

                    (* See if we have this type in the current environment or in some structure in
                       the current environment.  The name we have may be a full structure path. *)
                    fun nameToList ("", l) = (l, false) (* Not there. *)
                    |   nameToList (s, l) = 
                        let
                            val { first, second } = splitString s
                            val currentList = second :: l
                        in
                            if findType(env, currentList)
                            then (currentList, true)
                            else nameToList(first, currentList)
                        end
                    (* Try the type constructor name first.  This is usually accurate.  If not
                       fall back to the type identifier.  This may be needed in rarer cases. *)
                    val names =
                        case nameToList(constrName, []) of
                            (names, true) => names (* Found the type constructor name. *)
                        |   (names, false) =>
                            let
                                (* Try the type identifier name. *)
                                val TypeId { description = { name=idName, ...}, ...} =
                                    case (sigMap, tcIdentifier typeConstructor) of
                                    (SOME map, TypeId{idKind=Bound{offset, ...}, ...}) => map offset
                                |   (_, id) => id
                            in
                                if idName = "" then names
                                else
                                case nameToList(idName, []) of
                                    (idNames, true) => idNames
                                |   (_, _) => names (*@ ["(*N*)"] *) (* Temporary marker *)(* Use the type constructor name anyway. *)
                            end
                    val newName = String.concatWith "." names
                    (* TODO: If we don't find the type we want we should:
                       1.  If it's a type equivalence apply that.
                       2.  Report this in much more detail.  Perhaps the type has
                           been hidden e.g. by a type with the same name. *)
                     (* Get the declaration position for the type constructor. *)
                    val constrContext =
                        if isUndefined(pling value) then []
                        else
                        (
                            case List.find(fn DeclaredAt _ => true | _ => false) (tcLocations(pling value)) of
                                SOME(DeclaredAt loc) => [ContextLocation loc]
                            |   _ => []
                        )
                    val constructorEntry = 
                        PrettyBlock(0, false, constrContext, [PrettyString newName(*constrName*)])
                in
                    case args of
                        [] => constructorEntry
                    |   args as hd :: tl =>
                        let
                            val argVal = eventual hd;
                        in
                            PrettyBlock (0, false, [],
                            [
                                (* If we have just a single argument and it's just a type constructor
                                   or a construction we don't need to parenthesise it. *)
                                if null tl andalso not (isProductType argVal orelse isFunctionType argVal)
                                then dispP (argVal, depth - 1)
                                else if depth <= 1
                                then PrettyString "..."
                                else PrettyBlock(0, false, [],
                                         [PrettyString "(", PrettyBreak (0, 0)]
                                         @ prettyList args (depth - 1) ","
                                         @ [PrettyBreak (0, 0), PrettyString ")"]
                                     ),
                                PrettyBreak(1, 0),
                                constructorEntry (* The constructor. *)
                            ])
                        end
                end
        
            |   FunctionType {arg, result} =>
                if depth <= 0
                then PrettyString "..."
                else (* print out in infix notation *)
                let
                    val evArg = eventual arg;
                in
                    PrettyBlock (0, false, [],
                        [
                        (* If the argument is a function it must be printed as (a-> b)->.. *)
                        if isFunctionType evArg 
                        then parenthesise depth evArg
                        else dispP (evArg, depth - 1),
                        PrettyBreak(1, 0),
                        PrettyString "->",
                        PrettyBreak (1, 0),
                        dispP (result, depth - 1)
                        ])
                end
                     
            |   LabelledType {recList, frozen, ...} =>
                if depth <= 0
                then PrettyString "..."
                else if isProductType typ
                then (* Print as a product *)
                    PrettyBlock (0, false, [], (* Print them as t1 * t2 * t3 .... *)
                        prettyList (map (fn {typeof, ...} => typeof) recList) depth "*")
                else (* Print as a record *)
                PrettyBlock (2, false, [],
                    PrettyString "{" ::
                    (let
                        fun pRec [] _ = []
                          | pRec ({name, typeof} :: T) depth =
                            if depth <= 0 then [PrettyString "..."]
                            else
                                [
                                PrettyBlock(0, false, [],
                                    [
                                        PrettyBlock(0, false, [],
                                            [
                                            PrettyString (name ^ ":"),
                                            PrettyBreak(1, 0),
                                            dispP(typeof, depth - 1)
                                            ] @
                                            (if null T then [] else [PrettyBreak (0, 0), PrettyString ","])
                                        )
                                    ]@
                                    (if null T then [] else PrettyBreak (1, 0) :: pRec T (depth-1))
                                    )
                                ]
                    in
                        pRec recList (depth - 1)
                    end) @
                    [ PrettyString (if frozen then "}" else case recList of [] =>   "...}" | _  => ", ...}")]
                    )

            |   OverloadSet {typeset = []} => PrettyString "no type"

            |   OverloadSet {typeset = tconslist} =>
                (* This typically arises when printing error messages in the second pass because
                   the third pass will select a single type e.g. int where possible.  To
                   simplify the messages select a single type if possible. *)
                (
                    case preferredOverload tconslist of
                        SOME tcons => dispP(mkTypeConstruction (tcName tcons, tcons,[], []), depth)
                    |   NONE =>
                      (* Just print the type constructors separated by / *)
                    let
                        fun constrLocation tcons =
                            case List.find(fn DeclaredAt _ => true | _ => false) (tcLocations tcons) of
                                SOME(DeclaredAt loc) => [ContextLocation loc]
                            |   _ => []
                        (* Type constructor with context. *)
                        fun tconsItem tcons =
                            PrettyBlock(0, false, constrLocation tcons, [PrettyString(tcName tcons)])

                        fun printTCcons [] = []
                          | printTCcons [tcons] = [tconsItem tcons]
                          | printTCcons (tcons::rest) =
                                tconsItem tcons :: PrettyBreak (0, 0) ::
                                PrettyString "/" :: printTCcons rest
                    in
                        PrettyBlock (0, false, [], printTCcons tconslist)
                    end
                )

            |   EmptyType => PrettyString "no type"
            
            |   BadType => PrettyString "bad"
        end (* dispP *)
    in
        dispP (t, depth)
    end (* tDisp *);

  (* Generate unique type-variable names. *)

  fun varNameSequence () : typeVarForm -> string = 
  (* We need to ensure that every distinct type variable has a distinct name.
     Each new type variable is given a name starting at "'a" and going on
     through the alphabet. *)
  let
    datatype names = Names of {name: string, entry: typeVarForm};
    val nameNum    = ref ~1;
    val gNameList  = ref []; (* List of names *)
  in
    (* If the type is already there return the name we have given it
       otherwise make a new name and put it in the list. *)
    fn (var : typeVarForm) =>
        case List.find (fn (Names {entry,...}) => sameTv (entry, var)) (!gNameList) of
            NONE =>  (* Not on the list - make a new name *)
            let
                fun name num = (if num >= 26 then name (num div 26 - 1) else "")
                      ^ String.str (Char.chr (num mod 26 + Char.ord #"a"));
                val () = nameNum := !nameNum + 1;
                val n = (if tvEquality var then "''" else "'") ^ name(!nameNum);
                (* Should explicit type variables be distinguished? *)
            in
                gNameList := Names{name=n, entry=var} :: !gNameList;
                n
            end
       |    SOME (Names {name,...}) => name
           
  end (* varNameSequence *);
  

  (* Print a type (as a block of items) *)
  fun displayWithMap (t : types, depth : int, env, sigMap) =
      tDisp (t, depth, varNameSequence (), env, sigMap)
  and display (t : types, depth : int, env) =
      tDisp (t, depth, varNameSequence (), env, NONE)

  (* Print out one or more type variables (unblocked) *)
  fun printTypeVars
     (vars : typeVarForm list,
      depth : int,
      typeV : typeVarForm -> string)
     : pretty list =
  let
    val numOfVars = length vars;
  in
    (* Just print the variable *)
    if numOfVars = 1 
    then 
    [
      tDisp (TypeVar(hd vars), depth, typeV, emptyTypeEnv, NONE), 
      PrettyBreak (1, 0)
    ]
    else if numOfVars > 1 
    then (* Must parenthesise them. *)
         if depth <= 1 then [PrettyString "..."]
    else
        [
            PrettyBlock(0, false, [],
                PrettyString "(" ::
                PrettyBreak(0, 0) ::
                (let
                    fun pVars vars depth: pretty list = 
                        if depth <= 0 then [PrettyString "..."]
                        else if null vars then []
                        else
                        [
                            tDisp (TypeVar(hd vars), depth, typeV, emptyTypeEnv, NONE),
                            PrettyBreak (0, 0)
                        ] @
                        (if null (tl vars) then []
                         else PrettyString "," :: PrettyBreak (1, 0) :: pVars (tl vars) (depth - 1)
                        )
                in
                    pVars vars depth
                end) @ [PrettyString ")"]
            ),
            PrettyBreak (1, 0)
        ]
        
      else (* numVars < 1 *) []
  end (* printTypeVars *);
  
  
  (* Version used in parsetree. *)
  fun displayTypeVariables (vars : typeVarForm list, depth : int) =
      printTypeVars (vars, depth, varNameSequence ())
    
    
  (* Prints out a type constructor e.g. type 'a fred = 'a * 'a
     or datatype 'a joe = bill of 'a list | mary of 'a * int or
     simply type 'a abs if the type is abstract. *)
  fun displayTypeConstrsWithMap (tCons : typeConstrs, depth : int, typeEnv, sigMap) : pretty =
  let
    val typeV : typeVarForm -> string = varNameSequence ();
  in
    if depth <= 0 
    then PrettyString "..."
    else if not (null (tcConstructors tCons))
      then let (* It has constructors - datatype declaration *)
         (* Print a single constructor (blocked) *)
         fun pValConstr (first, name, typeOf, depth): pretty list =
             [
                 PrettyBreak (1, if first then 2 else 0),
                 PrettyBlock (0, false, [],
                     PrettyBlock (0, false, [],
                        (if first then PrettyBreak (0, 2)
                         else PrettyBlock (0, false, [], [PrettyString "|", PrettyBreak(1, 2)]) 
                         ) ::
                         (if depth <= 0 then [PrettyString "..."]
                         else
                            PrettyString name ::
                            (   (* Function - get the argument type *)
                                if isFunctionType typeOf
                                then [PrettyBreak (1, 4), PrettyString "of"]
                                else []
                            )
                         )
                    ) ::
                    (if isFunctionType typeOf andalso depth > 0
                    then
                    [
                        PrettyBreak (1, 4),
                        (* print the type as a single block of output *)
                        tDisp (#arg (typesFunctionType typeOf), depth - 1, typeV, typeEnv, sigMap)
                    ]
                    else [])
                 )
             ]; (* pValConstr *)
           
         (* Print a sequence of constructors (unblocked) *)
         fun pValConstrRest ([],     _    ): pretty list = []
           | pValConstrRest (H :: T, depth): pretty list =
               if depth < 0 then []           
               else 
                   pValConstr (false, valName H, valTypeOf H, depth) @
                     pValConstrRest (T, depth - 1)
           
         fun pValConstrList ([],     _    ) = PrettyString "" (* shouldn't occur *)    
           | pValConstrList (H :: T, depth) =
               PrettyBlock (2, true, [],
                   pValConstr (true, valName H, valTypeOf H, depth) @
                   pValConstrRest (T, depth - 1)
                   )

        in
            PrettyBlock(0, false, [],
                [
                    PrettyBlock(0, false, [],
                            PrettyString "datatype" ::
                            PrettyBreak (1, 2) ::
                            printTypeVars (tcTypeVars tCons, depth, typeV) @
                            [ PrettyString(#second(splitString(tcName tCons))), PrettyBreak(1, 0), PrettyString "=" ]
                    ),
                    pValConstrList (tcConstructors tCons, depth - 1)
                ]
            )
        end
       
    else if tcIsAbbreviation tCons
    then
    let
        val typeV = varNameSequence () (* Local sequence for this binding. *)
    in
        PrettyBlock (3, false, [],
            PrettyString (
                if not(tcIsAbbreviation tCons) andalso tcEquality tCons then "eqtype" else "type") ::
            PrettyBreak (1, 0) ::
            printTypeVars (tcTypeVars tCons, depth, typeV) @
            [
                PrettyString (#second(splitString(tcName tCons))),
                PrettyBreak(1, 0),
                PrettyString "=",
                PrettyBreak(1, 0),
                tDisp(tcEquivalent tCons, depth-1, typeV, typeEnv, sigMap)
            ]
            )
    end
    else (* An abstract type or a type bound to another type name. *)
        PrettyBlock (3, false, [],
            PrettyString (
                if tcEquality tCons then "eqtype" else "type") ::
            PrettyBreak (1, 0) ::
            printTypeVars (tcTypeVars tCons, depth, typeV) @
            [PrettyString (#second(splitString(tcName tCons)))]
            )
  end   (* displayTypeConstrsWithMap *);

    fun displayTypeConstrs (tCons : typeConstrs, depth : int, typeEnv) : pretty =
        displayTypeConstrsWithMap(tCons, depth, typeEnv, NONE)

    (* Parse tree for types.  This is used to represent types in the source. *)
    datatype typeParsetree =
        ParseTypeConstruction of
            { typeof: types, args: typeParsetree list,
              location: location, nameLoc: location, argLoc: location }
    |   ParseTypeProduct of
            { typeof: types, fields: typeParsetree list, location: location }
    |   ParseTypeFunction of
            { typeof: types, argType: typeParsetree, resultType: typeParsetree, location: location }
    |   ParseTypeLabelled of
            { typeof: types, fields: ((string * location) * typeParsetree * location) list,
              frozen: bool, location: location }
    |   ParseTypeId of
            { typeof: types, location: location }
    |   ParseTypeBad (* Place holder for errors. *)

    fun typeFromTypeParse(ParseTypeConstruction{ typeof, ...}) = typeof
    |   typeFromTypeParse(ParseTypeProduct{ typeof, ...}) = typeof
    |   typeFromTypeParse(ParseTypeFunction{ typeof, ...}) = typeof
    |   typeFromTypeParse(ParseTypeLabelled{ typeof, ...}) = typeof
    |   typeFromTypeParse(ParseTypeId{ typeof, ...}) = typeof
    |   typeFromTypeParse(ParseTypeBad) = BadType
    
    fun makeParseTypeConstruction((constrName, nameLoc), (args, argLoc), location) =
    let
        val argTypes = List.map typeFromTypeParse args
        val construction =
            TypeConstruction {name = constrName, value = VariableRef (ref undefType),
                              args = argTypes, locations = [DeclaredAt location]}
    in
        ParseTypeConstruction{
            typeof = construction, nameLoc = nameLoc, args = args, argLoc = argLoc, location = location }
    end

    fun makeParseTypeProduct(fieldList, location) =
    let
        val fieldTypes = List.map typeFromTypeParse fieldList
        val tuple = mkProductType fieldTypes
    in
        ParseTypeProduct{ typeof = tuple, fields = fieldList, location = location }
    end

    fun makeParseTypeFunction(arg, result, location) =
    let
        val function =
            mkFunctionType(typeFromTypeParse arg, typeFromTypeParse result)
    in
        ParseTypeFunction{ typeof = function, argType = arg, resultType = result, location = location }
    end

    fun makeParseTypeLabelled(fieldList, frozen, location) =
    let
        fun makeField((name, _), t, _) = mkLabelEntry(name, typeFromTypeParse t)        
        val fieldTypes = sortLabels(List.map makeField fieldList)
        val labelled = mkLabelled(fieldTypes, frozen)
    in
        ParseTypeLabelled{ typeof = labelled, fields = fieldList, frozen = frozen, location = location }
    end

    fun makeParseTypeId(types, location) =
        ParseTypeId{ typeof = TypeVar types, location = location }

    fun unitTree location =
        ParseTypeConstruction{
            typeof = unitType, args = [], argLoc = location, location = location, nameLoc = location }

    (* Build an export tree from the parse tree. *)
    fun typeExportTree(navigation, p: typeParsetree) =
    let        
        val typeof = typeFromTypeParse p

        (* Common properties for navigation and printing. *)
        val commonProps =
            PTprint(fn d => display(typeof, d, emptyTypeEnv)) ::
            PTtype typeof ::
            exportNavigationProps navigation

        fun asParent () = typeExportTree(navigation, p)
        
    in
        case p of
            ParseTypeConstruction{ location, typeof, nameLoc, args, argLoc, ...} =>
            let
                (* If the constructor has been bound return the declaration location. *)
                val (name, decLoc) =
                    case typeof of
                        TypeConstruction { value, name, ...} =>
                            if isUndefined (pling value)
                            then (name, [])
                            else (name, mapLocationProps(tcLocations(pling value)))
                    |   _ => ("", []) (* Error? *)
                val navNameAndArgs =
                (* Separate cases for nullary, unary and higher type constructions. *)
                    case args of
                        [] => [] (* Singleton e.g. int *)
                    |   [oneArg] =>
                        let (* Single arg e.g. int list. *)
                            (* Navigate between the type constructor and the argument.
                               Since the arguments come before the constructor we go there first. *)
                            fun getArg () =
                                typeExportTree({parent=SOME asParent, previous=NONE, next=SOME getName}, oneArg)
                            and getName () =
                                getStringAsTree({parent=SOME asParent, previous=SOME getArg, next=NONE},
                                            name, nameLoc, [])
                        in
                            [PTfirstChild getArg]
                        end
                    |   args =>
                        let (* Multiple arguments e.g. (int, string) pair *)
                            fun getArgs () =
                                (argLoc,
                                    exportList(typeExportTree, SOME getArgs) args @
                                        exportNavigationProps{parent=SOME asParent, previous=NONE, next=SOME getName})
                            and getName () =
                                getStringAsTree({parent=SOME asParent, previous=SOME getArgs, next=NONE},
                                            name, nameLoc, [])
                        in
                            [PTfirstChild getArgs]
                        end
            in
                (location, navNameAndArgs @ decLoc @ commonProps)
            end

        |   ParseTypeProduct{ location, fields, ...} =>
                (location, exportList(typeExportTree, SOME asParent) fields @ commonProps)

        |   ParseTypeFunction{ location, argType, resultType, ...} =>
                (location, exportList(typeExportTree, SOME asParent) [argType, resultType] @ commonProps)

        |   ParseTypeLabelled{ location, fields, ...} =>
            let
                fun exportField(navigation, label as ((name, nameLoc), t, fullLoc)) =
                    let
                        (* The first position is the label, the second the type *)
                        fun asParent () = exportField (navigation, label)
                        fun getLab () =
                            getStringAsTree({parent=SOME asParent, next=SOME getType, previous=NONE},
                                name, nameLoc, [PTtype(typeFromTypeParse t)])
                        and getType () =
                            typeExportTree({parent=SOME asParent, previous=SOME getLab, next=NONE}, t)
                    in
                        (fullLoc, PTfirstChild getLab :: exportNavigationProps navigation)
                    end
            in
                (location, exportList(exportField, SOME asParent) fields @ commonProps)
            end

        |   ParseTypeId{ location, ...} =>
                (location, commonProps)

        |   ParseTypeBad =>
                (nullLocation, commonProps)
    end


  (* When we have finished processing a list of patterns we need to check
     that the record is now frozen. *)

  fun recordNotFrozen (TypeVar t) : bool = 
        (* Follow the chain *)
        recordNotFrozen (tvValue t)
    | recordNotFrozen (LabelledType { frozen, ... }) = not frozen
    | recordNotFrozen _ = false (* record or type alias *);

    datatype match = Matched of {old: typeVarForm, new: types};


  (* Generate a mapping from one set of type variables to another. *)

  fun tvarSequence (matched : match list) : types -> types = 
  let
    val madeList = ref matched (* List of tyVars. *);
  in
    fn (atyp : types) => 
    let
      val tyVar = typesTypeVar atyp;
      
      (* See if we have already made a type variable for it. *)
      fun pTypeVar ([] : match list) =
        let  (* Not on the list - make a new name *)
          (* Make a unifiable type variable even if the original
             is nonunifiable. *)
          val n : types = 
            mkTypeVar (generalisable, tvEquality tyVar, false); 
        in
          (* Set the new variable to have the same value as the
             existing.  That is only really needed if we have an
             overload set. *)
          tvSetValue (typesTypeVar n, tvValue tyVar);
          madeList := Matched {old = tyVar, new = n} :: !madeList;
          n
        end
        
        | pTypeVar (Matched {old, new} :: rest) =
          if sameTv (old, tyVar) then new else pTypeVar rest;
    in
      pTypeVar (!madeList)
    end
  end (* tvarSequence *);

  fun generaliseTypes (atyp : types, matched : match list) : types = 
  let
    val tvs : types -> types = tvarSequence matched;

    fun copyTypeVar (atyp as TypeVar tyVar) =
      if tvLevel tyVar <> generalisable
      then atyp (* Not generalisable. *)
      else (* Unbound, overload set or flexible record *)
         let
            val newTv = tvs atyp
         in
            (* If we have a type variable pointing to a generic flexible record we have
               to retain a reference to the original so that we can add fields as necessary.
               We also have to generalise the fields since that won't have been done.
               The generic instance includes any generic instances used in the original
               type. *)
            case tvValue tyVar of
                valu as LabelledType{genericInstance, ...} =>
                    (
                    case copyType (valu, copyTypeVar, fn t => t)  of
                        LabelledType{recList, frozen, ... } =>
                            tvSetValue (typesTypeVar newTv,
                                LabelledType{recList = recList, frozen = frozen,
                                    genericInstance = tyVar :: genericInstance})
                    |   _ => raise InternalError "Copy of labelled record is not a labelled record"
                    )
            |   _ => ();
            newTv
         end
     | copyTypeVar atyp = atyp
  in
    (* Only process type variables. Return type constructors unchanged. *)
    copyType (atyp, copyTypeVar, fn t => t (*copyTCons*))
  end (* generaliseTypes *);


    (* Exported wrapper for generaliseTypes. *)
    fun generalise (atyp : types) : types = generaliseTypes (atyp, []);
    
  (* Make a match list from a list of type variables and types. *)
  
  fun copyVars (varlist : typeVarForm list, arglist : types list) : match list =
    case (varlist, arglist) of
      (var::vars, arg::args) =>
        Matched {old = var, new = arg} :: copyVars (vars, args)
    | _  => [] (* These will normally be nil at the same time but if we have
                  had an error they may not be. *)
  
   (* Find the argument type which gives this result when the constructor
      is applied. If we have, for example, a value of type int list and
      we have discovered that this is a "::" node we have to work back by
      comparing the type of "::" ('a * 'a list -> 'a list) to find the
      argument of the constructor (int * int list) and hence how to print it.
     (Actually "list" is treated specially). *)
  fun constructorResult (constrType : types, typeArgs : types list) : types =
  let
    val constrFun = typesFunctionType constrType;
  in
    generaliseTypes
      (#arg constrFun, 
       copyVars (List.map typesTypeVar (#args (typesTypeConstruction (#result constrFun))), typeArgs))
  end;

    (* If we have a type construction which is an alias for another type
       we construct the alias by first instantiating all the type variables
       and then copying the type. *)
    fun makeEquivalent (atyp, args) =
        case tcIdentifier atyp of
            TypeId{typeFn=(_, EmptyType), ...} => raise InternalError "makeEquivalent: Not a type function"
        |   TypeId{typeFn=(typeArgs, typeResult), ...} =>
                generaliseTypes(typeResult, copyVars (typeArgs, args))

    (* Look for the occurrence of locally declared datatypes in the type of a value. *)
    fun checkForLocalDatatypes(ty: types, depth: int, errorFn: string->unit) : unit =
    let
        fun checkTypes (typ: types) (ok: bool) : bool =
        case typ of
            TypeConstruction {value, args, ...} =>
            let
                val constr = pling value
            in
                if tcIsAbbreviation constr
                then (* May be an alias for a type that contains a local datatype. *)
                    foldType checkTypes (makeEquivalent (constr, args)) ok
                else if ok andalso tcLetDepth constr > depth
                then
                    (
                    errorFn("Type contains local datatype (" ^ tcName constr ^")");
                    false
                    )
                else true
            end
        |   _ => true
    in
        foldType checkTypes ty true;
        ()
    end

  (* This 3-valued logic is used because in a few cases we may not be sure
     if equality testing is allowed. If we have 2 mutually recursive datatypes
     t = x of s | ... and s = z of t we would first examine "t", find that
     it uses "s", look at "s", find that refers back to "t". To avoid
     infinite recursion we return the result that equality "maybe"
     allowed for "t" and hence for "s". However we may find that the
     other constructors for "t" do not allow equality and so equality
     will not be allowed for "s" either. *)
     
  datatype tri = Yes (* 3-valued logic *)
               | No
               | Maybe;


  (* Returns a flag saying if equality testing is allowed for values of
     the given type. "equality" is used both to generate the code for
     a specific call of equality e.g.  (a, b, c) = f(x), and to generate
     the equality operation for a type when it is declared. In the latter
     case type variables may be parameters which will be filled in later e.g.
     type 'a list = nil | op :: of ('a * 'a list). "search"
     is a function which looks up constructors in mutually recursive type
     declarations. "lookupTypeVar" deals with type variables. If they
     represent parameters to a type declaration equality 
     checking will be allowed. If we are unifying this type to an equality
     type variable they  will be unified to new equality type variables.
     Otherwise equality is not allowed. *)
    
  fun equality (ty, search, lookupTypeVar) : tri =
  let
    (* Can't use foldT because it is not monotonic
       (equality on ref 'a is allowed). *)
    (* Returns Yes only if equality testing is allowed for all types
       in the list. *)
    fun eqForList ([],    soFar) = soFar
      | eqForList (x::xs, soFar) = 
        case equality (x, search, lookupTypeVar) of
           No    => No
         | Maybe => eqForList (xs, Maybe)
         | Yes   => eqForList (xs, soFar);
  in
    case eventual ty of
      TypeVar tyVar => (* The type variable may point to a flexible record or
                          an overload set or it may be the end of the chain.
                          If this is a labelled record we have to make sure that
                          any fields we add also admit equality.
                          lookupTypeVar makes the type variable an equality type
                          so that any new fields are checked for equality but
                          we also have to call "equality" to check the existing
                          fields. *)
        if tvEquality tyVar then Yes
        else
            (
            case tvValue tyVar of
                lab as LabelledType _ =>
                    (
                    case lookupTypeVar tyVar of
                        No => No
                      | _ => equality (lab, search, lookupTypeVar)
                    )
             | _ => lookupTypeVar tyVar
            )
   
   | FunctionType {...} =>
       No  (* No equality on function types! *)
    
   | TypeConstruction {value, args, ...} =>
        let
            val constr = pling value;
        in
            if isUndefined constr
            then No

            else if tcIsAbbreviation constr
            then (* May be an alias for a type that allows equality. *)
                equality (makeEquivalent (constr, args), search, lookupTypeVar)

            (* ref - Equality is permitted on refs of all types *)
            (* The Definition of Standard ML says that ref is the ONLY type
               constructor which is treated in this way.  The standard basis
               library says that other mutable types such as array should
               also work this way. *)
            else if isPointerEqType(tcIdentifier constr)
            then Yes

            (* Others apart from ref and real *)
            else if tcEquality constr (* Equality allowed. *)
            then eqForList (args, Yes) (* Must be allowed for all the args *)
      
            else
            let (* Not an alias. - Look it up. *)
                val s = search (tcIdentifier constr);
            in 
                if s = No then No else eqForList (args, s)
            end
       
        end (* TypeConstruction *)
         
   | LabelledType {recList, ...} => (* Record equality if all subtypes are (ignore frozen!) *)
        (* TODO: Avoid copying the list? *)
       eqForList (map (fn{typeof, ...}=>typeof) recList, Yes)

   | OverloadSet _ =>
        (* This should not happen because all overload sets should be pointed
           to by type variables and so should be handled in the TypeVar case. *)
        raise InternalError "equality - Overloadset found"

   | BadType =>
      No

   | EmptyType => (* shouldn't occur *)
      No
  end;

  (* When a datatype is declared we test to see if equality is allowed. The
     types are mutually recursive so value constructors of one type may
     take arguments involving values of any of the others. *)
     
    fun computeDatatypeEqualities(types, boundIdEq) =
    let
        datatype state =
          Processed of tri              (* Already processed or processing. *)
        | NotSeen   of typeConstrs list (* Value is list of constrs. *);
    
        (* This table tells us, for each type constructor, whether it definitely
           admits equality, definitely does not or whether we have yet to look
           at it. *)

        fun isProcessed (Processed _) = true | isProcessed _ = false;
    
        fun stateProcessed (Processed x) = x | stateProcessed _ = raise Match;
        fun stateNotSeen   (NotSeen   x) = x | stateNotSeen   _ = raise Match;
    
        val {enter:typeId * state -> unit,lookup} = mapTable sameTypeId;

        (* Look at each of the constructors in the list. Equality testing is
           only allowed if it is allowed for each of the alternatives. *)
        fun constrEq _           []       soFar = soFar (* end of list - all o.k. *)
        |   constrEq constructor (h :: t) soFar =
            (* The constructor may be a constant e.g.
               datatype 'a list = nil | ... or  a function e.g.
               datatype 'a list = ... cons of 'a * 'a list. *)
            if not (isFunctionType (valTypeOf h)) (* Constant *)
            then constrEq constructor t soFar (* Go on to the next. *)
      
            else
            let
                (* Function - look at the argument type. *)
                (* Equality is allowed for any type-variable.  The only type variables
                   allowed are parameters to the datatype so if we have a type variable
                   then equality is allowed for this datatype.  *)
                val eq = 
                    equality (#arg (typesFunctionType (valTypeOf h)),
                        genEquality, fn _ => Yes);
            in
                if eq = No
                then (* Not allowed. *) No
                else (* O.k. - go on to the next. *)
                    constrEq constructor t (if eq = Maybe then Maybe else soFar)
            end (* constrEq *)

        (* This procedure checks to see if equality is allowed for this datatype. *)
        and genEquality constructorId =
        let 
            (* Look it up to see if we have already done it. It may fail because
               we may have constructors that do not admit equality. *)
            val thisState =
                case (lookup constructorId, constructorId) of
                    (SOME inList, _) => inList
                |   (NONE, TypeId{idKind = Bound{offset, ...}, ...}) =>
                        Processed(if boundIdEq offset then Yes else No)
                |   _ => Processed No
        in
            if isProcessed thisState
            then stateProcessed thisState (* Have either done it already or are currently doing it. *)
            else (* notSeen - look at it now. *)
            let
                (* Equality is allowed for this datatype only if all of them admit it.
                   There are various other alternatives but this is what the standard says.
                   If the "name" is rigid (free) we must not grant equality if it is not 
                   already there although that is not an error. *)
                (* Set the state to "Maybe". This prevents infinite recursion. *)
                val () = enter (constructorId, Processed Maybe);
                val eq =
                    List.foldl 
                        (fn (cons, t) => 
                        if t = No
                        then No
                        else constrEq cons (tcConstructors cons) t)
                        Yes
                        (stateNotSeen thisState);
            in
                (* Set the state we have found if it is "yes" or "no".  If it is
                   maybe we have a recursive reference which appears to admit
                   equality, but may not. E.g. if we have
                             datatype t = A of s | B of int->int  and  s = C of t
                   if we start processing "t" we will go on to "s" and do that
                   before returning to "t". It is only later we find that "t" does
                   not admit equality. If we get "Maybe" as the final result when
                   all the recursion has been unwound we can set the result to
                   "yes", but any intermediate "Maybe"s have to be done again. *)
                enter (constructorId, if eq = Maybe then thisState else Processed eq);
                eq
            end
        end (* genEquality *);
    in
        (* If we have an eqtype we set it to true, otherwise we set all of them
           to "notSeen" with the constructor as value. *)
        List.app 
            (fn dec => 
            let  (* If we have two datatypes which share we may already have
                    one in the table.  We have to link them together. *)
                val tclist =
                    case lookup (tcIdentifier dec) of
                        NONE => [dec]
                    |   SOME l =>
                        let
                            val others = stateNotSeen l
                            val newList = dec :: others;
                        in
                            (* If any of these are already equality types (i.e. share with an eqtype)
                               then they all must be. *)
                            if tcEquality dec orelse tcEquality (hd others)
                            then List.app (fn d => tcSetEquality (d, true)) newList
                            else ();
                            newList
                        end
            in
                enter (tcIdentifier dec, NotSeen tclist)
            end) types;

        (* Apply genEquality to each element of the list. *)
        List.app
            (fn constructor => 
            let
                val constructorId = tcIdentifier constructor;
                val eqForCons     = genEquality constructorId;
            in
                (* If the result is "Maybe" it involves a recursive reference, but
                   the rest of the type allows equality. The type admits equality. *)
                if eqForCons = No
                then () (* Equality not allowed *)
                else
                ( (* Turn on equality. *)
                    enter (constructorId, Processed Yes);
                    tcSetEquality (constructor, true)
                )
            end) types
    end (* computeDatatypeEqualities *);
    
    datatype matchResult =
        SimpleError of types * types * string
    |   TypeConstructorError of types * types * typeConstrs * typeConstrs

    (* Type matching algorithm for both unification and signature matching. *)
    (* The mapping has now been moved out of here.  Instead when signature matching the
       target signature is copied before this is called which means that this
       process is now symmetric.  There may be some redundant tests left in here. *)
    fun unifyTypes(Atype : types, Btype : types) : matchResult option =
    let
        (* Get the result in here.  This isn't very ML-like but it greatly
           simplifies converting the code. *)
        val matchResult: matchResult option ref = ref NONE
        fun matchError error = (* Only report one error. *)
            case matchResult of ref (SOME _) => () | r => r := SOME error
        fun cantMatch(alpha, beta, text) = matchError(SimpleError(alpha, beta, text))
  
    fun match (Atype : types, Btype : types) : unit =
    let (* Check two records/tuples and return the combined type. *)
      fun unifyRecords ({frozen=typAFrozen, recList=typAlist, genericInstance = gA},
                        {frozen=typBFrozen, recList=typBlist, genericInstance = gB},
                        typA : types, typB : types) : types =
      let
        (* If we add a field to the instance we have to add a corresponding type variable to
           the generic. *)
        fun addFieldToGeneric field generic =
        let
            (* The new entry is just a type variable. *)
            val newEntry =
                (
                (*print(concat[
                    "newEntry:",
                    "equality=", Bool.toString(tvEquality generic),
                    " level=", Int.toString(tvLevel generic),
                    "\n"
                ]);*)
                { name = field,
                  (* The entry must at least inherit the equality attribute.
                     We should have tvLevel generic = generalisable and tvNonUnifiable generic
                     = false. *)
                  typeof = mkTypeVar(tvLevel generic, tvEquality generic,
                                tvNonUnifiable generic)}
                )
            fun addEntry [] = [newEntry]
             |  addEntry ((ge as {name, typeof = _}) :: geRest) =
                    let
                        val order = compareLabels (name, field)
                    in
                        if order = 0
                        then ge :: geRest (* Already there - this may be a duplicate. *)
                        else if order < 0
                        then ge :: addEntry geRest
                        else newEntry :: ge :: geRest
                    end
        in
            case tvValue generic of
                LabelledType { recList, frozen = false, ...} =>
                    tvSetValue(generic,
                        LabelledType { recList = addEntry recList, frozen = false,
                                genericInstance = []})
            |   LabelledType { recList, frozen = true, ...} =>
                    let
                        (* It seems that in obscure circumstances (see regression file
                           p073) we can have a generic that is already frozen.  In that
                           case all the field we want to add should already be in the
                           frozen record otherwise it's an error.
                           I don't really understand this and I don't know whether it's
                           actually possible to have a missing field at this point. *)
                        fun checkEntries [] = ()
                        |   checkEntries (({name, typeof = _}) :: geRest) =
                            let
                                val order = compareLabels (name, field)
                            in
                                if order = 0 (* It's there *)
                                then ()
                                else if order < 0
                                then checkEntries geRest
                                else cantMatch (typA, typB, "(Field " ^ name ^ " missing)")
                            end
                    in
                        checkEntries recList
                    end
            |   _ => raise InternalError "addFieldToGeneric: Not a labelled record"
        end

        fun freezeGeneric generic =
            case tvValue generic of
                LabelledType { recList, ...} =>
                    tvSetValue(generic,
                        LabelledType { recList = recList, frozen = true, genericInstance = []})
            |   _ => raise InternalError "freezeGeneric: Not a labelled record"

        fun matchLabelled ([], []) = []
          
             (* Something left in bList - this is fine if typeA is not frozen.
                e.g.  (a: s, b: t) will match (a: s, ...) but not just (a:s). *)
          | matchLabelled ([], bList as {name=bName, ...} :: _) =
           ( 
            if typAFrozen
            then cantMatch (typA, typB, "(Field " ^ bName ^ " missing)")
            else (* Add all the extra fields in bList to all the generics for A. *)
                List.app(fn {name, ...} => List.app (addFieldToGeneric name) gA) bList;
            bList (* return the remainder of the list *)
           )

          | matchLabelled (aList as {name=aName, ...} :: _, []) = (* Something left in bList *)
            ( 
             if typBFrozen
             then cantMatch (typA, typB, "(Field " ^ aName ^ " missing)")
             else List.app(fn {name, ...} => List.app (addFieldToGeneric name) gB) aList;
             aList (* the rest of aList *)
            )
        
          | matchLabelled (aList as ((aVal as {name=aName,typeof=aType})::aRest),
                           bList as ((bVal as {name=bName,typeof=bType})::bRest)) =
             (* both not nil - look at the names. *)
             let
               val order = compareLabels (aName, bName);
             in
               if order = 0 (* equal *)
               then (* same name - must be unifiable types *)
               ( (* The result is (either) one of these with the rest of the list. *)
                 match (aType, bType);
                 aVal :: matchLabelled (aRest, bRest)
               )
               else if order < 0 (* aName < bName *)
                then 
                ( (* The entries in each list are in order so this means that this
                     entry is not in bList. If the typeB is frozen this is an error. *)
                  if typBFrozen (* Continue with the entry removed. *)
                  then (cantMatch (typA, typB, "(Field " ^ aName ^ " missing)"); aList)
                  else
                     (
                     List.app (addFieldToGeneric aName) gB;
                     aVal :: matchLabelled (aRest, bList)
                     )
                )
                else (* aName > bName *)
                  if typAFrozen
                  then (cantMatch (typA, typB, "(Field " ^ bName ^ " missing)"); bList)
                  else
                     (
                     List.app (addFieldToGeneric bName) gA;
                     bVal :: matchLabelled (aList, bRest)
                     )
             end (* not nil *);
 
        (* Return the combined list. Only actually used if both are flexible. *)
        val result =
            if typAFrozen andalso typBFrozen andalso List.length typAlist <> List.length typBlist
            then (* Don't attempt to unify the fields if we have the wrong number of items.
                    If we've added or removed an item from a tuple e.g. a function with
                    multiple arguments, it's more useful to know this than to get unification
                    errors on fields that don't match. *)
               (cantMatch (typA, typB, "(Different number of fields)"); [])
            else matchLabelled (typAlist, typBlist)
        (* We append the generic instances.  This may create duplicates if, for example,
           we are unifying a record with itself. *)
      in
        if typAFrozen
        then (if typBFrozen then () else List.app freezeGeneric gB; typA)
        else if typBFrozen
        then (if typAFrozen then () else List.app freezeGeneric gA; typB)
        else LabelledType {recList = result, frozen = false, genericInstance = gA @ gB}
      end (* unifyRecords *);

    (* Sets a type variable to a value. - Checks that the type variable
       we are assigning does not occur in the expression we are about to
       assign to it. Such cases can occur if we have infinitely-typed
       expressions such as fun a. a::a where a has type 'a list list ...
       Also propagates the level information of the type variable.
       Now also deals with flexible records. *)
    fun assign (var, t) =
    let
      (* Mapped over the type to be assigned. *)
      (* Returns "true" if it is safe to make the assignment. Sorts out
         imperative type variables and propagates level information.
         N.B. It does not propagate equality status. The reason is that
         if we are unifying ''a with '_b ref, the '_b does NOT become
         an equality type var. In all other cases it would. *)
      fun checkForLoops _ false = false
       |  checkForLoops (TypeVar tvar) true =
           let
             (* The level is the minimum of the two, and if we are unifying with
                an equality type variable we must make this into one. *)
             val minLev = Int.min (tvLevel var, tvLevel tvar);
           in
             if tvLevel tvar <> minLev
             then 
               (* If it is nonunifiable we cannot make its level larger. *)
               if tvNonUnifiable tvar
               then cantMatch (Atype, Btype,
                        "(Type variable is free in surrounding scope)")
               else let
                 (* Must make a new type var with the right properties *)
                 (* This type variable may be a flexible record, in which
                    case we have to save the record and put it on the new
                    type variable. foldType will apply checkForLoops to the
                    record. *)
                 val newTv = mkTypeVar (minLev, tvEquality tvar, false);
               in
                 tvSetValue (typesTypeVar newTv, tvValue tvar);
                 tvSetValue (tvar, newTv)
               end
             else ();
             not (sameTv (tvar, var)) (* Safe if vars are different. *)
           end
       |  checkForLoops _ true = true
         (* end checkForLoops *);
                   
      val varVal = tvValue var (* Current value of the variable to be set. *)
    in (* start of "assign" *)
        case varVal of
            LabelledType _ =>
            (* Flexible record. Check that the records are compatible. *)
                match (varVal, t)
          | OverloadSet _ =>
             (* OverloadSet.  Check that the sets match.  This is only in the
                case where t is something other than an overload set since
                we remove the overload set from a variable when unifying two
                sets. *)
                match (varVal, t)
          | _ => ();
 
      (* If this type variable was put in explicitly then it can't be
         assigned to something else. (We have already checked for the
         type variables being the same). *) 
      if tvNonUnifiable var orelse not (foldType checkForLoops t true)
      then let
        (* The one case where an apparent occurs check is not an error
           is when unifying 'a with ('a,'b) x, where x was defined by
           type ('a,'b) x = 'a. In this case we are really unifying 'a and 'a
           and so there is no problem. *)
        (* This originally just checked a single level of expansion.  I've
           now turned it into a function to handle arbitrary levels. e.g.
           (('a, 'b) x, 'c) x   DCJM 22/8/00. *)
        fun checkRealError (TypeConstruction {value, args, ...}) =
            let
                val constr = pling value
            in
              not (tcIsAbbreviation constr) orelse
                  let
                    (* expand type constructor to get its body *)
                    val equiv = eventual (makeEquivalent (constr, args));
                  in
                    checkRealError equiv
                  end
            end
          | checkRealError (TypeVar tv) =
                (* is it the same type variable that we started with? *)
                not (sameTv (tv, var))
          | checkRealError _ = true

        val realError = checkRealError t
      in
        if realError
        then let
          (* generate the right error message. *)
          val msg =
            if tvNonUnifiable var
            then "(Cannot unify with explicit type variable)"
            else "(Type variable to be unified occurs in type)";
        in
          cantMatch (Atype, Btype, msg)
        end
        else ()
      end

      else let (* Occurs check succeeded. *)
        fun canMkEqTv (tvar : typeVarForm) : tri = 
          (* Turn it into an equality type var. *)
          if tvEquality tvar then Yes 
          (* If it is nonunifiable we cannot make it into an equality type var. *)
          else if tvNonUnifiable tvar then No
          else (* Must make a new type var with the right properties *)
          let  (* This type variable may be a flexible record or an overload set,
                  in which case we have to save the record and put it on the
                  new type variable.
                  We have to do both because we have to ensure that the existing
                  fields in the flexible record admit equality and ALSO that any
                  additional fields we may add by unification with other records
                  also admit equality. *)
            val newTv = mkTypeVar (tvLevel tvar, true, false);
            val oldValue = tvValue tvar
          in
            tvSetValue (tvar, newTv);
            (* If this is an overloaded type we must remove any types that
               don't admit equality. *)
            case oldValue of
               OverloadSet{typeset} =>
                    let
                    (* Remove any types which do not admit equality. *)
                       fun filter [] = []
                        |  filter (h::t) =
                                if tcEquality h then h :: filter t else filter t
                    in
                        case filter typeset of
                            [] => No
                          | [constr] =>
                            ( (* Turn a singleton into a type construction. *)
                            tvSetValue (typesTypeVar newTv,
                                mkTypeConstruction(tcName constr, constr, nil, []));
                            Yes
                            )
                          | newset =>
                            (
                            tvSetValue (typesTypeVar newTv, OverloadSet{typeset=newset});
                            Yes
                            )
                    end
              | _ => (* Labelled record or unbound variable. *)
                (
                tvSetValue (typesTypeVar newTv, oldValue);
                Yes
                )
          end;
      
       in
          (* If we are unifying a type with an equality type variable
             we must ensure that equality is allowed for that type. This
             will turn most type variables into equality type vars. *)
          if tvEquality var andalso equality (t, fn _ => No, canMkEqTv) = No
          then cantMatch (Atype, Btype, "(Requires equality type)")
              (* TODO: This can result in an unhelpful message if var is bound
                 to a flexible record since there is no indication in the
                 printed type that the flexible record is an equality type.
                 It would be improved if we set the value to be EmptyType.
                 At least then the type variable would be printed which would
                 be an equality type.
                 --- Adding the "Requires equality type" should improve things. *)
          else ();
         (* Actually make the assignment. It doesn't matter if var is 
            a labelled record, because t will be either a fixed record
            or a combination of the fields of var and t.  Likewise if
            var was previously an overload set this may replace the set
            by a single type construction. *)
         (* If we have had an error don't make the assignment.  At the very least
            it could prevent us producing useful error information and it could
            also result in unnecessary consequential errors. *)
         case !matchResult of
            NONE => tvSetValue (var, t)
         |  SOME _ => ()
       end
     end (* assign *);

    (* First find see if typeA and typeB are unified to anything
       already, and get the end of a list of "flexibles". *)
    val tA = eventual Atype;
    val tB = eventual Btype;

    in (* start of "match" *)
    if isUndefinedType tA orelse isUndefinedType tB
    then () (* If either of these was an undefined type constructor don't try to match. 
               TODO: There are further tests below for this which are now redundant. *)
    else
    case (tA, tB) of
        (BadType, _) => () (* If either is an error don't try to match *)
      | (_, BadType) => ()

      | (TypeVar typeAVar, TypeVar typeBVar) =>
            (* Unbound type variable, flexible record or overload set. *)
            let
                (* Even if this is a one-way match we can allow type variables
                   in the typeA to be instantiated to anything in the typeB. *)
                val typeAVal = tvValue typeAVar;
                (* We have two unbound type variables or flex. records. *)
            in
                if sameTv (typeAVar, typeBVar) (* same type variable? *)
                then ()
                else (* no - assign one to the other *)
                    if tvNonUnifiable typeAVar
                    (* If we have a nonunifiable type variable we want to assign
                       the typeB to  it. If the typeB is nonunifiable as well we
                       will get an error message. *)
                then assign (typeBVar, tA)
                else
                let 
                    (* If they are both flexible records we first set the typeB
                       to the union of the records, and then set the typeA to
                       that. In that way we propagate properties such as
                       equality and level between the two variables. *)
                    val typBVal = tvValue typeBVar
                in
                    case (typeAVal, typBVal) of
                        (LabelledType recA, LabelledType recB) =>
                        (
                          (* Turn these back into simple type variables to save
                             checking the combined record against the originals
                             when we make the assignment.
                             (Would be safe but redundant). *)
                          tvSetValue (typeBVar, emptyType);
                          tvSetValue (typeAVar, emptyType);
                          assign (typeBVar,
                                  unifyRecords (recA, recB, typeAVal, typBVal));
                          assign (typeAVar, tB)
                        )
                     | (OverloadSet{typeset=setA}, OverloadSet{typeset=setB}) =>
                        let
                            (* The lists aren't ordered so we just have to go
                               through by hand. *)
                            fun intersect(_, []) = []
                              | intersect(a, H::T) =
                                    if isInSet(H, a) then H::intersect(a, T) else intersect(a, T)
                            val newSet = intersect(setA, setB)
                        in
                            case newSet of
                                [] => cantMatch (Atype, Btype, "(Incompatible overloadings)")
                             | _ =>
                                (
                                  tvSetValue (typeBVar, emptyType);
                                  tvSetValue (typeAVar, emptyType);
                                  (* I've changed this from OverloadSet{typeset=newset}
                                     to use mkOverloadSet.  The main reason was that it
                                     fixed a bug which resulted from a violation of the
                                     assumption that "equality" would not be passed an
                                     overload set except when pointed to by a type variable.
                                     It also removed the need for a separate test for
                                     singleton sets since mkOverloadSet deals with them.
                                     DCJM 1/9/00. *)
                                  assign (typeBVar, mkOverloadSet newSet);
                                  assign (typeAVar, tB)
                                )
                        end
                     | (EmptyType, _) => (* A is not a record or an overload set. *)
                         assign (typeAVar, tB)
                     | (_, EmptyType) => (* A is a record but B isn't *)
                            assign (typeBVar, tA) (* typeB is ordinary type var. *)
                     | _ => (* Bad combination of labelled record and overload set *)
                        cantMatch (Atype, Btype, "(Incompatible types)")
                end
          end

      | (TypeVar typeAVar, _) =>
            (* typeB is not a type variable so set typeA to typeB.*)
            (* Be careful if this is a non-unifiable type variable being matched to
               the special case of the identity type-construction. *)
        (
            if tvNonUnifiable typeAVar
            then
                (
                case tB of
                    TypeConstruction {value, args, ...} =>
                    let
                        val constr = pling value
                    in
                        if isUndefined constr orelse not (tcIsAbbreviation constr)
                        then
                            (
                            case tB of
                                TypeConstruction {value, args, ...} =>
                                let
                                    val constr = pling value
                                in
                                    if isUndefined constr orelse not (tcIsAbbreviation constr)
                                    then assign (typeAVar, tB)
                                    else match(tA, eventual (makeEquivalent (constr, args)))
                                end
                            | _ => assign (typeAVar, tB)
                            )
                        else match(tA, eventual (makeEquivalent (constr, args)))
                    end
                |  _ => assign (typeAVar, tB)
                )
            else assign (typeAVar, tB)
        )
         
      | (_, TypeVar typeBVar) => (* and typeA is not *)
        (
            (* We have to check for the special case of the identity type-construction. *)
            if tvNonUnifiable typeBVar
            then
                (
                case tA of
                    TypeConstruction {value, args, ...} =>
                    let
                        val constr = pling value
                    in
                        if isUndefined constr orelse not (tcIsAbbreviation constr)
                        then
                            (
                            case tB of
                                TypeVar tv =>
                                  (* This will fail if we are matching a signature because the
                                     typeB will be non-unifiable. *)
                                    assign (tv, tA) (* set typeB to typeA *)
                              | typB => match (tA, typB)
                            )
                        else match(eventual (makeEquivalent (constr, args)), tB)
                    end
                |  _ =>
                    (
                    case tB of
                        TypeVar tv =>
                          (* This will fail if we are matching a signature because the
                             typeB will be non-unifiable. *)
                            assign (tv, tA) (* set typeB to typeA *)
                      | typB => match (tA, typB)
                    )
                )
            else
                (
                case tB of
                    TypeVar tv =>
                      (* This will fail if we are matching a signature because the
                         typeB will be non-unifiable. *)
                        assign (tv, tA) (* set typeB to typeA *)
                  | typB => match (tA, typB)
                )
        )
              
      | (TypeConstruction({value = valueA, args=tAargs, ...}), 
         TypeConstruction ({value = valueB, args=tBargs, ...})) =>
            let
                val tACons = pling valueA and tBCons = pling valueB
            in
                (* We may have a number of possibilities here.
                 a) If tA is an alias we simply expand it out and recurse (even
                 if tB is the same alias). e.g. if we have string t where
                 type 'a t = int*'a we expand string t into int*string and
                 try to unify that.
                 b) map it and see if the result is an alias. -- NOW REMOVED
                 c) If tB is a type construction and it is an alias we expand
                 that e.g. unifying "int list" and "int t" where type
                 'a t = 'a list (particularly common in signature/structure
                 matching.)
                 d) Finally we try to unify the stamps and the arguments. *)
                if isUndefined tACons orelse isUndefined tBCons
                then () (* If we've had an undefined type constructor don't try to check further. *)
                else if tcIsAbbreviation tACons
                (* Candidate is an alias - expand it. *)
                then match (makeEquivalent (tACons, tAargs), tB)
                else if tcIsAbbreviation tBCons
                then match (tA, makeEquivalent (tBCons, tBargs))
                else
                let
                    val typeBCons = pling valueB
                in
                    (* If the typeB is an alias it must be expanded. *)
                    if tcIsAbbreviation typeBCons
                    then match (tA, makeEquivalent (typeBCons, tBargs))
                    else if sameTypeId (tcIdentifier tACons, tcIdentifier typeBCons)
                    then
                    let (* Same type constructor - do the arguments match? *)
                        fun matchLists []      []    = ()
                          | matchLists (a::al) (b::bl) =
                          (  
                            match (a, b);
                            matchLists al bl
                          )
                          | matchLists _ _ = (* This should only happen as a result of
                                                a different error. *)
                                cantMatch (Atype, Btype, "(Different numbers of arguments)")
                    in
                            matchLists tAargs tBargs
                    end

                    (* When we have different type constructors, especially two with the same name,
                       we try to produce more information. *)
                    else matchError(TypeConstructorError(tA, tB, tACons, typeBCons))
                end
        end

      | (OverloadSet {typeset}, TypeConstruction {value=valueB, args=tBargs, ...}) =>
        (* The candidate is an overloaded type and the target is a type
           construction. *)
        let
            val tBCons = pling valueB
        in
            if not (isUndefined tBCons orelse not (tcIsAbbreviation tBCons))
            then match (tA, makeEquivalent (tBCons, tBargs))
            else
            let
                val typeBCons = pling valueB
            in
                if isUndefined typeBCons
                then ()
                else if tcIsAbbreviation typeBCons
                then match (tA, makeEquivalent (typeBCons, tBargs))
                else (* See if the target type is among those in the overload set. *)
                    if null tBargs (* Must be a nullary type constructor. *)
                        andalso isInSet(tBCons, typeset)
                then () (* ok. *)
                    (* Overload sets arise primarily with literals such as "1" and it's
                       most likely that the error is a mismatch between int and another
                       type rather than that the user assumed that the literal was
                       overloaded on a type it actually wasn't. *)
                else
                case preferredOverload typeset of
                    NONE => cantMatch (tA, tB, "(Different type constructors)")
                |   SOME prefType =>
                    matchError(
                        TypeConstructorError(
                            mkTypeConstruction (tcName prefType, prefType,[], []),
                            tB, prefType, typeBCons))
            end
        end

      | (TypeConstruction {value=valueA, args=tAargs, ...}, OverloadSet {typeset}) =>
        let
            val tACons = pling valueA
        in
            if not (isUndefined tACons orelse not (tcIsAbbreviation tACons))
            then match (makeEquivalent (tACons, tAargs), tB)
            (* We should never find an overload set as the target for a signature
               match but it is perfectly possible for tB to be an overload set
               when unifying two types.  *)
            else if null tAargs andalso isInSet(tACons, typeset)
            then () (* ok. *)
            else
            case preferredOverload typeset of
                NONE => cantMatch (tA, tB, "(Different type constructors)")
            |   SOME prefType =>
                matchError(
                    TypeConstructorError(
                        tA, mkTypeConstruction (tcName prefType, prefType,[], []),
                        tACons, prefType))
        end
        
      (* (OverloadSet , OverloadSet) should not occur because that should be
         handled in the (TypeVar, TypeVar) case. *)
        
      | (TypeConstruction({value = valueA, args=tAargs, ...}), _) =>
        let
            val tACons = pling valueA
        in
            if not (isUndefined tACons orelse not (tcIsAbbreviation tACons))
            (* Candidate is an alias - expand it. *)
            then match (makeEquivalent (tACons, tAargs), tB)
            else (* typB not a construction (but typeA is) *)
                cantMatch (tA, tB, "(Incompatible types)")
        end
        
      | (_, TypeConstruction {value=valueB, args=tBargs, ...}) => (* and typeA is not. *)
        (* May have a type equivalence e.g. "string t" matches int*string if  type
           'a t = int * 'a . Alternatively we may be matching a structure to a signature
           where the signature says "type t" and the structure contains "type 
           t = int->int" (say). We need to set the type in the signature to int->int. *)
        let
            val tBCons = pling valueB
        in
            if not (isUndefined tBCons orelse not (tcIsAbbreviation tBCons))
            then match (tA, makeEquivalent (tBCons, tBargs))
            else
            let
                val typeBCons = pling valueB
            in
                if isUndefined typeBCons
                then ()
                else if tcIsAbbreviation typeBCons
                then match (tA, makeEquivalent (typeBCons, tBargs))
                else cantMatch (tB, tA, "(Incompatible types)")
            end
        end
         
      | (FunctionType {arg=typAarg, result=typAres, ...},
         FunctionType {arg=typBarg, result=typBres, ...}) =>
        ( (* must be unifiable functions *)
            (* In principle it doesn't matter whether we unify arguments or
               results first but it could affect the error messages.  Is this
               the best way to do it? *)
            match (typAarg, typBarg);
            match (typAres, typBres)
        )

      | (EmptyType, EmptyType) => ()
            (* This occurs only with exceptions - empty means no argument *)
    
      | (LabelledType recA, LabelledType recB) =>
          (* Unify the records, but discard the result because at least one of the
             records is frozen. *)
            (unifyRecords (recA, recB, tA, tB); ())
            
      | _ => cantMatch (tA, tB, "(Incompatible types)")

    end; (* match *)

    in
        match (Atype, Btype);
        ! matchResult
    end; (* unifyTypes *)

    (* Turn a result from matchTypes into a pretty structure so that it
       can be included in a message. *)
    fun unifyTypesErrorReport (_, alphaTypeEnv, betaTypeEnv, what) =
    let
        fun reportError(SimpleError(alpha: types, beta: types, reason)) =
            (* This previously used a single type variable sequence for
               both types.  It may be that this is needed to make
               sensible error messages. *)
            PrettyBlock(3, false, [],
                [
                    PrettyString ("Can't " ^ what (* "match" if a signature, "unify" if core lang. *)),
                    PrettyBreak (1, 0),
                    display (alpha, 1000 (* As deep as necessary *), alphaTypeEnv),
                    PrettyBreak (1, 0),
                    PrettyString "to",
                    PrettyBreak (1, 0),
                    display (beta, 1000 (* As deep as necessary *), betaTypeEnv),
                    PrettyBreak (1, 0),
                    PrettyString reason                        
                ])

        |   reportError(TypeConstructorError(alpha: types, beta: types, alphaCons, betaCons)) =
            let
                fun expandedTypeConstr(ty, tyEnv, tyCons) =
                let
                    fun lastPart name = #second(splitString name)

                    (* Print the type which includes the type constructor name with as
                       much additional information as we can. *)
                    fun printWithDesc{ location, name, description } =
                        PrettyBlock(3, false, [],
                            [ display (ty, 1000, tyEnv) ]
                            @ (if lastPart name = lastPart(tcName tyCons) then []
                               else
                                [
                                    PrettyBreak(1, 0),
                                    PrettyString "=",
                                    PrettyBreak(1, 0),
                                    PrettyBlock(0, false, [ContextLocation location], [PrettyString name])
                                ]
                              )
                            @ (if description = "" then []
                               else
                                [
                                    PrettyBreak(1, 0),
                                    PrettyBlock(0, false, [ContextLocation location],
                                        [PrettyString ("(*" ^ description ^ "*)")])
                                ]
                              )
                            )
                in
                    case tcIdentifier tyCons of
                        TypeId { description, ...} => printWithDesc description
                end
            in
                PrettyBlock(3, false, [],
                    [
                        PrettyString ("Can't " ^ what (* "match" if a signature, "unify" if core lang. *)),
                        PrettyBreak (1, 0),
                        expandedTypeConstr(alpha, alphaTypeEnv, alphaCons),
                        PrettyBreak (1, 0),
                        PrettyString (if what = "unify" then "with" else "to"),
                        PrettyBreak (1, 0),
                        expandedTypeConstr(beta, betaTypeEnv, betaCons),
                        PrettyBreak (1, 0),
                        PrettyString "(Different type constructors)"                        
                    ])
            end
            
    in
        reportError
    end

  (* Given a function type returns the first argument if the
     function takes a tuple otherwise returns the only argument.
     Extended to include the case where the argument is not a function
     in order to work properly for overloaded literals. *)
  fun firstArg(FunctionType{arg=
        LabelledType { recList = {typeof, ...} ::_, ...}, ...}) =
            eventual typeof
   |  firstArg(FunctionType{arg, ...}) = eventual arg
   |  firstArg t = t

  (* Returns the result type of a function. *)
  fun getResult(FunctionType{result, ...}) = eventual result
   |  getResult _ = raise InternalError "getResult - not a function";

  (* Returns an instance of an overloaded function using the supplied
     list of type constructors for the overloading. *)
  fun generaliseOverload(t, constrs, isConverter) =
    let
        val arg =
            if isConverter
            then getResult t
            else firstArg t
    in
        case arg of
            TypeVar tv =>
                (* The argument should be a type variable, possibly set to
                   an empty overload set.  This should be replaced by
                   the current overload set in the copied function type. *)
                generaliseTypes(t, [Matched{old=tv, new=mkOverloadSet constrs}])
          | _ => raise InternalError "generaliseOverload - arg is not a type var"
    end

    (* Return a type constructor from an overload.  If there are
       several (i.e. the overloading has not resolved to a single type)
       it returns the "best".  This is called in the third pass so it
       should never be called if there is not at least one type that
       is possible. *)
    fun typeConstrFromOverload(f, _) =
    let
    fun prefType(TypeVar tvar) =
            ( (* If we still have an overload set that's because it has
                 not reduced to a single type.  In ML 97 we default to
                 int, real, word, char or string in that order.  This
                 works correctly for overloading literals so long as
                 the literal conversion functions are correctly installed. *)
            case tvValue tvar of
                OverloadSet{typeset} =>
                    let
                        (* If we accept this type we have to freeze the
                            overloading to this type.
                            I'm not happy about doing this here but it
                            seems the easiest solution. *)
                        fun freezeType tcons =
                            (
                            tvSetValue(tvar,
                                mkTypeConstruction(tcName tcons, tcons, [], []));
                            tcons
                            )
                    in
                        case preferredOverload typeset of
                            SOME tycons => freezeType tycons
                        |   NONE => raise InternalError "typeConstrFromOverload: No matching type"
                    end
              | _ => raise InternalError "typeConstrFromOverload: No matching type" (* Unbound or flexible record. *)
            )
     |  prefType(TypeConstruction{value, args, ...}) =
            let
                val constr = pling value
            in
                if not (tcIsAbbreviation constr)
                then constr (* Generally args will be nil in this case but
                               in the special case of looking for an equality
                               function for 'a ref or 'a array it may not be.  *)
                else prefType (makeEquivalent (constr, args))
            end
     |  prefType _ = raise InternalError "typeConstrFromOverload: No matching type"
    in
        prefType(firstArg(eventual f))
    end;

    (* Return the result type of a function.  Also used to test if the value is
       a function type. *)
    fun getFnArgType t =
    case eventual t of
        FunctionType {arg, ... } => SOME arg
    |   _ => NONE
    

  (* Assigns type variables to variables with generalisation permitted
     if their level is at least that of the current level.
     In ML90 mode this produced an error message for any top-level
     free imperative type variables.  We don't do that in ML97 because
     it is possible that another declaration may "freeze" the type variable
     before the composite expression reaches the top level. *)
  fun allowGeneralisation (t, level, nonExpansive, lex, location, moreInfo, typeEnv) =
    let
        fun giveError(s1: string, s2: string) =
        let
            (* Use a single sequence. *)
            val vars : typeVarForm -> string = varNameSequence ();
            open DEBUG
            val parameters = debugParams lex
            val errorDepth = getParameter errorDepthTag parameters
        in
            reportError lex
            {
                hard = true,
                location = location,
                message =
                    PrettyBlock (3, false, [],
                        [
                            PrettyString s1,
                            PrettyBreak (1, 0),
                            tDisp (t, errorDepth, vars, typeEnv, NONE),
                            PrettyBreak (1, 0),
                            PrettyString s2
                        ]
                    ),
                context = SOME(moreInfo ())
            }
        end

        fun general (TypeVar tvar) showError =
            if tvLevel tvar >= level andalso
                tvLevel tvar <> generalisable
            then let
                (* Is this an overload set ? *)
                val isOverloadSet = 
                    case tvValue tvar of
                        OverloadSet _ => true
                    |   _ => false

                (* Make a new generisable type variable, except that type
                   variables in an expansive context cannot be generalised.
                   We also don't generalise if this is an overload set.
                   The reason for that is that it allows us to get overloading
                   information from the surrounding context.
                   e.g. let fun f x y = x+y in f 2.0 end.  An alternative
                   would be take the default type (in this case int).
                   DCJM 1/9/00. *)
                val nonCopiable = not nonExpansive orelse isOverloadSet;
                val newLevel =
                   if nonCopiable then level-1 else generalisable (* copiable *);

                val isOk =
                    (* If the type variable has top-level scope then we have
                       a free type variable.  We only want to generate this
                       message once even if we have multiple type variables.*)
                    (* If the type variable is non-unifiable and the expression is
                       expansive then we have an error since this will have to
                       be a monotype.  *)
                    if tvNonUnifiable tvar andalso nonCopiable andalso showError
                    then
                        (
                        giveError("Type", "includes a free type variable");
                        false
                        )
                    else showError;
                val newVal =
                     mkTypeVar 
                       (newLevel, tvEquality tvar,
                        if nonCopiable then (tvNonUnifiable tvar) else false)
            in
                (* If an explicit type variable is going out of scope we can
                   generalise it, except if it is nonunifiable. *)
                (* It may be a flexible record so we have to transfer the
                   record to the new variable. *)
                tvSetValue (typesTypeVar newVal, tvValue tvar);
                tvSetValue (tvar, newVal);
                isOk
            end
            else showError
        | general _ isOk = isOk
    in
        foldType general t true;
        ()
    end (*  end allowGeneralisation *);


  (* Check for free type variables.  Added for ML97.  This replaces the
     test in allowGeneralisation above and is applied to all top-level
     values including those in structures and functors.  *)
  (* I've changed this from giving an error message, which prevented the
     code from evaluating, to giving a warning and setting the type
     variables to unique type variables.  That allows, for example,
     fun f x = raise x; f Subscript; to work.  DCJM 8/3/01. *)
  fun checkForFreeTypeVariables(valName: string, ty: types, lex: lexan, printAndEqCode) : unit =
  let
    (* Generate new names for the type constructors. *)
    val count = ref 0
    fun genName num =
        (if num >= 26 then genName (num div 26 - 1) else "")
        ^ String.str (Char.chr (num mod 26 + Char.ord #"a"));

    fun checkTypes (TypeVar tvar) () =
        if isEmpty(tvValue tvar) andalso tvLevel tvar = 1
        then (* The type variable is unbound (specifically, not
                an overload set) and it is not generic i.e. it
                must have come from an expansive expression. *)
            let
                val name = "_" ^ genName(!count)
                val _ = count := !count + 1;
                val declLoc = location lex (* Not correct but OK for the moment. *)
                val declDescription =
                    { location = declLoc, name = name, description = "Constructed from a free type variable." }
                val tCons =
                    makeFrozenTypeConstrs (name, [],
                        makeFreeId(Global(printAndEqCode()), tvEquality tvar, declDescription, ([], EmptyType)),
                        0, [DeclaredAt declLoc]);
                val newVal = mkTypeConstruction(name, tCons, [], [])
            in
                warningMessage(lex, location lex, 
                    concat["The type of (", valName,
                        ") contains a free type variable. Setting it to a unique monotype."]);
                tvSetValue (tvar, newVal)
            end
        else ()
     |  checkTypes _ () = ()

  in
      foldType checkTypes ty ();
    ()
  end

    (* Returns true if a type constructor permits equality. *)
    
    fun permitsEquality constr =
        if tcIsAbbreviation constr
        then typePermitsEquality(
                mkTypeConstruction (tcName constr, constr, List.map TypeVar (tcTypeVars constr), []))
        else tcEquality constr
   
    and typePermitsEquality ty = equality (ty, fn _ => No, fn _ => Yes) <> No

    (* See if a type abbreviation or "where type" has the form type t = s or
       type 'a t = 'a s etc and so is simply giving a new name to the type
       constructor.  If it is it then checks that the type constructor used
       (s in this example) is just a simple type name. *)
    fun typeNameRebinding(typeArgs, typeResult): typeId option =
    let
        fun eqTypeVar(TypeVar ta, tb) = sameTv (ta, tb)
        |   eqTypeVar _ = false
    in
        case typeResult of
            TypeConstruction {value, args, ... } =>
                if not (ListPair.allEq eqTypeVar(args, typeArgs))
                then NONE
                else
                (
                    case tcIdentifier (pling value) of
                        tId as TypeId{typeFn=(_, EmptyType), ...} => SOME tId
                    |   _ => NONE
                )
        |   _ => NONE
    end

  (* Returns the number of the entry in the list. Used to find out the
     location of fields in a labelled record for expressions and pattern
     matching. Assumes that the label appears in the list somewhere. *)
     
  fun entryNumber (label, LabelledType{recList, ...}) =
    let (* Count up the list. *)
      fun entry ({name, ...}::l) n =
        if name = label then n else entry l (n + 1)
       |  entry [] _ = raise Match
    in
      entry recList 0
    end
      
   | entryNumber (label, TypeVar tvar) =
        entryNumber (label, tvValue tvar)
      
   | entryNumber (label, TypeConstruction{value, ...}) = (* Type alias *)
        entryNumber (label, tcEquivalent(pling value))
      
   | entryNumber _ =
        raise InternalError "entryNumber - not a record"

  (* Size of a labelled record. *)

  fun recordWidth (LabelledType{recList, ...}) =
        length recList
      
   | recordWidth (TypeVar tvar) =
        recordWidth (tvValue tvar)
      
   | recordWidth (TypeConstruction{value, ...}) = (* Type alias *)
        recordWidth (tcEquivalent(pling value))
      
   | recordWidth _ =
        raise InternalError "entryNumber - not a record"

    (* Unify two type variables which would otherwise be non-unifiable.
       Used when we have found a local type variable with the same name
       as a global one. *)
  fun linkTypeVars (a, b) =
  let
    val ta = typesTypeVar (eventual(TypeVar a)); (* Must both be type vars. *)
    val tb = typesTypeVar (eventual(TypeVar b));
  in  (* Set the one with the higher level to point to the one with the
         lower, so that the effective level is the lower. *)
    if (tvLevel ta) > (tvLevel tb)
    then tvSetValue (ta, TypeVar b)
    else tvSetValue (tb, TypeVar a)
  end;

  (* Set its level by setting it to a new type variable. *)
  fun setTvarLevel (typ, level) =
  let
    val tv = typesTypeVar (eventual(TypeVar typ)); (* Must be type var. *)
  in
    tvSetValue (tv, mkTypeVar (level, tvEquality tv, true))
  end;

    structure Sharing =
    struct
        type types      = types
        and  values     = values
        and  typeId     = typeId
        and  structVals = structVals
        and  typeConstrs= typeConstrs
        and  typeParsetree = typeParsetree
        and  locationProp = locationProp
        and  pretty     = pretty
        and  lexan      = lexan
        and  ptProperties = ptProperties
        and  typeVarForm = typeVarForm
        and  codetree   = codetree
        and  matchResult = matchResult
    end
end (* TYPETREE *);
