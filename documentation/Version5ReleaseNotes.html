<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>
<title>Version 5 Release Notes</title>
</head>

<body bgcolor="#FFFFFF">
<script language="JavaScript" type="text/javascript"><!--
Allowhover = 
  (((navigator.appName == "Netscape") && 
  (parseInt(navigator.appVersion) >= 3 )) || 
  ((navigator.appName == "Microsoft Internet Explorer") && 
  (parseInt(navigator.appVersion) >= 4 ))); 

function Imagepreload(img) 
{
  var a=new Image(); a.src=img; return a; 
}
if(Allowhover) {
	Homen=Imagepreload('../images/HomeButton.gif');
	Homeh=Imagepreload('../images/HomeButton1.gif'); 
	Aboutn=Imagepreload('../images/AboutButton.gif');
	Abouth=Imagepreload('../images/AboutButton1.gif'); 
	Supportn=Imagepreload('../images/SupportButton.gif');
	Supporth=Imagepreload('../images/SupportButton1.gif'); 
	Getn=Imagepreload('../images/GetButton.gif');
	Geth=Imagepreload('../images/GetButton1.gif'); 
	Docn=Imagepreload('../images/DocButton.gif');
	Doch=Imagepreload('../images/DocButton1.gif'); 
}
// --></script>


<table border="0">
  <tr>
    <td valign="top"><table border="0" cellspacing="0" cellpadding="0">
      <tr>
        <td><a href="../index.html" onmouseover="if(Allowhover) document['Home'].src=Homeh.src; return true" onmouseout="if(Allowhover) document['Home'].src=Homen.src; return true"><img name="Home" src="../images/HomeButton.gif" alt="Poly/ML Home" border="0" WIDTH="113" HEIGHT="43"></a></td>
      </tr>
      <tr>
        <td><a href="../FAQ.html" onmouseover="if(Allowhover) document['About'].src=Abouth.src; return true" onmouseout="if(Allowhover) document['About'].src=Aboutn.src; return true"><img name="About" src="../images/AboutButton.gif" alt="About Poly/ML" border="0" WIDTH="113" HEIGHT="43"></a></td>
      </tr>
      <tr>
        <td><a href="../support.html" onmouseover="if(Allowhover) document['Support'].src=Supporth.src; return true" onmouseout="if(Allowhover) document['Support'].src=Supportn.src; return true"><img name="Support" src="../images/SupportButton.gif" alt="Support for Poly/ML" border="0" WIDTH="113" HEIGHT="43"></a></td>
      </tr>
      <tr>
        <td><a href="../Doc.html" onmouseover="if(Allowhover) document['Doc'].src=Doch.src; return true" onmouseout="if(Allowhover) document['Doc'].src=Docn.src; return true"><img name="Doc" src="../images/DocButton.gif" alt="Documentation" border="0" WIDTH="113" HEIGHT="43"></a></td>
      </tr>
      <tr>
        <td><a href="../download.html" onmouseover="if(Allowhover) document['Get'].src=Geth.src; return true" onmouseout="if(Allowhover) document['Get'].src=Getn.src; return true"><img name="Get" src="../images/GetButton.gif" alt="Get Poly/ML" border="0" WIDTH="113" HEIGHT="43"></a></td>
      </tr>
    </table>
    </td>
    <td valign="top">
	<h2><font face="Arial, Helvetica, sans-serif"><strong>Poly/ML Version 5</strong></font></h2>
<p><strong><font face="Arial, Helvetica, sans-serif"><strong>New Features</strong></font></strong></p>
<ul>
  <li><font face="Arial, Helvetica, sans-serif">Support for stand-alone binaries</font></li>
  <li><font face="Arial, Helvetica, sans-serif"> Support for additional platforms: 
    AMD64, Intel Macs, Cygwin</font></li>
  <li><font face="Arial, Helvetica, sans-serif"> No artificial limits on size 
    of heaps or saved image</font></li>
  <li><font face="Arial, Helvetica, sans-serif"> Uses standard GNU tools for building</font></li>
  <li><font face="Arial, Helvetica, sans-serif">Fixed address mmap and trap-handling 
    removed </font></li>
</ul>
<p><strong><font face="Arial, Helvetica, sans-serif"><strong>Version 5</strong></font></strong></p>
<p><font face="Arial, Helvetica, sans-serif">Thanks to some financial support 
  from the Verisoft project organised through the Technical University of Munich 
  I have spent several months updating the Poly/ML run-time system. There are 
  many internal changes detailed below but there is one major change that is likely 
  to affect all users. The persistent storage system that has been a feature of 
  Poly/ML almost since the beginning has finally reached its sell-by date and 
  has been removed. In its place there is the facility to export ML functions 
  as object files and link them to produce stand-alone executables.</font></p>
<p><font face="Arial, Helvetica, sans-serif">Although the ML code has not been 
  significantly changed, with the exception of a new code-generator for the 64-bit 
  AMD/Intel processor, the run-time system has been modified substantially. The 
  aim has been to try to produce a version that will work across a wider range 
  of systems than before and will be much simpler to maintain. The C code has 
  been converted to C++ and standard GNU tools: autoconf, automake and libtool 
  are used to build the system. Memory mapping to fixed addresses, which caused 
  problems with various Linux distributions, has been removed and the use of traps 
  to handle arbitrary precision overflow and heap limits has been replaced by 
  calls into the run-time system. The artificial limits on the size of the heap 
  and of the saved database have been removed and the only limit on the size of 
  the working heap is likely to be swap space.</font></p>
<p><font face="Arial, Helvetica, sans-serif">To build and install Poly/ML download 
  and unpack the source. You can then build poly with the commands</font></p>
<p><font face="Courier New, Courier, mono"> <strong>./configure<br>
  make<br>
  make install</strong></font></p>
<p><font face="Arial, Helvetica, sans-serif">./configure by default places installed 
  files within /usr/local and in particular the libraries are placed in /usr/local/lib. 
  Some Unix distributions (e.g. Fedora Core) do not include /usr/local/lib in 
  the library search path and on those distributions it may be better to override 
  this by specifying<br>
  <font face="Courier New, Courier, mono"><strong>./configure --prefix=/usr</strong></font></font></p>
<p><font face="Arial, Helvetica, sans-serif">You build an application by constructing 
  your application as an ML function and calling <font face="Courier New, Courier, mono">PolyML.export</font>. 
  <font face="Courier New, Courier, mono">PolyML.export</font> takes as its argument 
  a file name for the resulting object file and a function to export. It will 
  automatically add the normal extension for an object file (.o or .obj as appropriate) 
  unless it already included and write out the function and any data reachable 
  from it as a normal operating system object file. This can then be linked with 
  the poly libraries to build an application.</font></p>
<p><font face="Arial, Helvetica, sans-serif"><strong>Example of building an application</strong></font></p>
<p><font face="Courier New, Courier, mono">$ <strong>poly</strong><br>
  Poly/ML 5.0 Release<br>
  &gt; <strong>fun f () = print &quot;Hello World\n&quot;;</strong><br>
  val f = fn : unit -&gt; unit<br>
  &gt; <strong>PolyML.export(&quot;hello&quot;, f);</strong><br>
  val it = () : unit<br>
  &gt; <strong>^D</strong><br>
        $ <strong>cc -o hello hello.o -lpolymain -lpolyml</strong><br>
  $ <strong>./hello</strong><br>
  Hello World</font></p>
<p><font face="Arial, Helvetica, sans-serif">If you have installed the libraries 
  in a directory that is not in the search path you may need to add this. For 
  example<br>
        <font face="Courier New, Courier, mono">cc -o hello hello.o -L/usr/local/lib 
        -lpolymain -lpolyml</font><br>
        It is possible to use the ld command rather than cc here but you may need 
        to include some of the default C and C++ libraries on the command line. 
        On some platforms it may be necessary to add -lstdc++.</font></p>
<p><font face="Arial, Helvetica, sans-serif">It is often the case that applications 
  built using Poly/ML will want to use the normal Poly/ML top-level but with additional 
  ML functions or structures built in. In the old version this was achieved by 
  compiling the new declarations and then committing the database. The new version 
  does this slightly differently. First compile in the new declarations as before 
  and then export the Poly/ML top level by exporting <font face="Courier New, Courier, mono">PolyML.rootFunction</font>.</font></p>
<p><font face="Courier New, Courier, mono">$ <strong>poly</strong></font><font face="Arial, Helvetica, sans-serif"><br>
  <font face="Courier New, Courier, mono">Poly/ML 5.0 Release<br>
  &gt; <strong>val myValue = &quot;This is a new value&quot;;</strong><br>
  val myValue = &quot;This is a new value&quot; : string<br>
  &gt; <strong>PolyML.export(&quot;mypoly&quot;, PolyML.rootFunction);</strong><br>
  val it = () : unit<br>
  &gt; <strong>^D</strong><br>
        $ <strong>cc -o mypoly mypoly.o -lpolymain -lpolyml</strong><br>
  $ <strong>./mypoly</strong><br>
  Poly/ML 5.0 Beta1<br>
  &gt; <strong>myValue;</strong><br>
  val it = &quot;This is a new value&quot; : string<br>
  &gt; </font></font></p>
<p><font face="Courier New, Courier, mono">PolyML.export</font><font face="Arial, Helvetica, sans-serif"> 
  writes its output to an object file in the native format on the machine on which 
  it is running. Currently Poly/ML supports three different formats: ELF, used 
  on Linux, FreeBSD and Solaris; PCOFF, used on Windows and Cygwin and Mach-O, 
  used on Mac OS X. If it is necessary to distribute software in object format 
  it would be inconvenient to have to produce versions for each combination of 
  architecture (e.g. X86-32, X86-64, PPC and Sparc) and each possible object format. 
  To avoid this there is a <font face="Courier New, Courier, mono">PolyML.exportPortable</font> 
  function which takes similar arguments to <font face="Courier New, Courier, mono">PolyML.export</font> 
  but writes its output to a text file in a portable format. There is a <font face="Courier New, Courier, mono">polyimport</font> 
  command which loads a file stored in this format and runs it.</font></p>
<p><font face="Courier New, Courier, mono">$ <strong>poly</strong><br>
  Poly/ML 5.0 </font><font face="Arial, Helvetica, sans-serif"><font face="Courier New, Courier, mono">Release</font></font><font face="Courier New, Courier, mono"><br>
  &gt; <strong>fun f () = print &quot;Hello World\n&quot;;</strong><br>
  val f = fn : unit -&gt; unit<br>
  &gt; <strong>PolyML.exportPortable(&quot;hello&quot;, f);</strong><br>
  val it = () : unit<br>
  &gt; <strong>^D</strong><br>
  $ <strong>polyimport hello.txt</strong><br>
  Hello World</font></p>
<p><font face="Arial, Helvetica, sans-serif">While this is convenient for porting 
  the portable format is not designed for efficiency. The Poly/ML build process 
  uses the portable format within the distribution but the build script then exports 
  the code in the native format. N.B. The portable format only avoids the need 
  to produce different object code formats. It is not portable across different 
  architectures (e.g. i386 to PPC) since the portable file still contains native 
  machine instructions encoded as strings.</font></p>
<p><font face="Arial, Helvetica, sans-serif">The previous version of Poly/ML had 
  a command line option to compress a database by sharing immutable data. This 
  has been replaced in the new version by the <font face="Courier New, Courier, mono">PolyML.shareCommonData</font> 
  function. This takes as its argument any data structure and it processes this 
  structure replacing any multiple occurrences of the same immutable data by a 
  pointer to a single occurrence. In effect, wherever in the data structure there 
  are two substructures which would be equal using the ML definition of equality 
  there will be a pointer to a single data structure.</font></p>
<p><font face="Arial, Helvetica, sans-serif">The intended use of this is primarily 
  to reduce the size of a data structure before it is exported. It can be used 
  in the above example but in this case the function being exported is so simple 
  that it is unlikely to be worthwhile.</font></p>
  
<p> <font face="Courier New, Courier, mono">$ <strong>poly</strong><br>
  Poly/ML 5.0 </font><font face="Arial, Helvetica, sans-serif"><font face="Courier New, Courier, mono">Release</font></font><font face="Courier New, Courier, mono"><br>
  &gt; <strong>fun f () = print &quot;Hello World\n&quot;;</strong><br>
  val f = fn : unit -&gt; unit<br>
  &gt; <strong>PolyML.shareCommonData f;</strong><br>
  val it = () : unit<br>
  &gt; <strong>PolyML.export(&quot;hello&quot;, f);</strong><br>
  val it = () : unit<br>
  &gt; <strong>^D</strong></font></p>
<p><font face="Arial, Helvetica, sans-serif">The new version uses the standard 
  GNU tools: autoconf, automake and libtool. There is no need to install these 
  tools in order to install and run Poly/ML unless you need to make modifications 
  to the setup which are not handled within the configure and make files. Using 
  these tools should make porting to other versions of Unix easier and should 
  make it fairly simple to build binary or source distributions to include in 
  Unix distributions.</font></p>
<p><font face="Arial, Helvetica, sans-serif">The command line arguments to Poly/ML 
  have been simplified. There are a few command line arguments that are taken 
  by the Poly/ML run time system and the remainder are passed to the application 
  via the standard basis library CommandLine structure. The run-time system recognises 
  the following arguments:</font><font face="Arial, Helvetica, sans-serif">
 
  </font></p>
<table width="0%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="100"><font face="Arial, Helvetica, sans-serif">-H</font></td>
    <td width="404"><font face="Arial, Helvetica, sans-serif">&lt;Initial heap size (MB)&gt;</font></td>
  </tr>
  <tr> 
    <td width="100"><font face="Arial, Helvetica, sans-serif">--immutable</font></td>
    <td><font face="Arial, Helvetica, sans-serif">&lt;Initial size of immutable 
      buffer (MB)&gt;</font></td>
  </tr>
  <tr> 
    <td width="100"><font face="Arial, Helvetica, sans-serif">--mutable</font></td>
    <td><font face="Arial, Helvetica, sans-serif">&lt;Initial size of mutable 
      buffer(MB)&gt;</font></td>
  </tr>
  <tr> 
    <td width="100"><font face="Arial, Helvetica, sans-serif">--debug</font></td>
    <td><font face="Arial, Helvetica, sans-serif">&lt;Debug options&gt;</font></td>
  </tr>
  <tr> 
    <td width="100"><font face="Arial, Helvetica, sans-serif">--timeslice</font></td>
    <td><font face="Arial, Helvetica, sans-serif">&lt;Time slice (ms)&gt;</font></td>
  </tr>
</table>
<p><font face="Arial, Helvetica, sans-serif">The poly application itself recognises 
  a few arguments:
  </font></p>
<table width="0%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="100"><font face="Arial, Helvetica, sans-serif">-v</font></td>
    <td width="404"><font face="Arial, Helvetica, sans-serif">Print the version 
      of Poly/ML and exit</font></td>
  </tr>
  <tr> 
    <td width="100"><font face="Arial, Helvetica, sans-serif">--help</font></td>
    <td><font face="Arial, Helvetica, sans-serif">Print the list of arguments 
      and exit</font></td>
  </tr>
  <tr> 
    <td width="100"><font face="Arial, Helvetica, sans-serif">-q</font></td>
    <td><font face="Arial, Helvetica, sans-serif">Suppress the start-up message</font></td>
  </tr>
</table>

<p><font face="Arial, Helvetica, sans-serif">If you are building your own application 
  that recognises --help as a command line argument you should call <font face="Courier New, Courier, mono">PolyML.rtsArgumentHelp()</font> 
  to retrieve the information about the run-time system arguments and include 
  this in any help text you produce.</font></p>
<p><font face="Arial, Helvetica, sans-serif">The heap size arguments set the initial 
  heap size but the heap may grow beyond this if your application needs more space. 
  If no argument is set the default size is half the physical memory available 
  on your machine.</font></p>
<p></p>
<p>DCJM 2nd January 2007</p>
    </td>
  </tr>
</table>
</body>
</html>
